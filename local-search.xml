<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>博客搬家啦</title>
    <link href="/2021/12/31/hello-world/"/>
    <url>/2021/12/31/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="这是一篇测试博客。"><a href="#这是一篇测试博客。" class="headerlink" title="这是一篇测试博客。"></a>这是一篇测试博客。</h1><p>2021-12-31搬家啦，从<a href="https://www.vultr.com/">vultr</a>搬到<a href="https://pages.github.com/">GitHub Pages</a>了，采用<a href="https://hexo.io/">hexo</a>重新搭建。</p><p>搬家过程中有部分内容遗失，本站正在逐步恢复。</p><h2 id="代码高亮测试"><a href="#代码高亮测试" class="headerlink" title="代码高亮测试"></a>代码高亮测试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mate</span> <span class="hljs-attr">charest</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="流程图测试"><a href="#流程图测试" class="headerlink" title="流程图测试"></a>流程图测试</h2><pre><code class=" mermaid">graph TD  A([A]) --&gt;|test| B(B)  B --&gt; C(C)  C --&gt;|One| D[D]  C --&gt;|Two| E[E]  C --&gt;|Three| F[F]</code></pre><h2 id="科学公式测试"><a href="#科学公式测试" class="headerlink" title="科学公式测试"></a>科学公式测试</h2><p>$$<br>E=mc^2<br>$$</p><p>$$<br>(\sqrt{3x-1}+(1+x)^2)<br>$$</p><p>$$<br>\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue style 穿透样式选择器</title>
    <link href="/2021/04/12/vue-style-%E7%A9%BF%E9%80%8F%E6%A0%B7%E5%BC%8F%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2021/04/12/vue-style-%E7%A9%BF%E9%80%8F%E6%A0%B7%E5%BC%8F%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-style-穿透样式选择器"><a href="#Vue-style-穿透样式选择器" class="headerlink" title="Vue style 穿透样式选择器"></a>Vue style 穿透样式选择器</h1><p>开发vue项目中经常会引入一些组件，无论是自定义组件还是引入的外部组件，style标签上经常会设置<code>scoped</code>属性，vue组件编译后，会将 template 中的每个元素加入<code>[data-v-xxxx]</code>属性来确保<code>style scoped</code>仅本组件的元素而不会污染全局。</p><p>但如果你引用了第三方组件，又需要在父组件更改子组件的样式。就要用到组件穿透（也叫深度修改css）。</p><h2 id="解决方法1：混用本地和全局样式"><a href="#解决方法1：混用本地和全局样式" class="headerlink" title="解决方法1：混用本地和全局样式"></a>解决方法1：混用本地和全局样式</h2><p>一个.vue文件允许多个style，你可以在一个组件中同时使用有 scoped 和非 scoped 样式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less">&lt;<span class="hljs-selector-tag">style</span>&gt;<br><span class="hljs-comment">/* 全局样式 */</span><br>&lt;/<span class="hljs-selector-tag">style</span>&gt;<br> <br>&lt;<span class="hljs-selector-tag">style</span> <span class="hljs-selector-tag">scoped</span>&gt;<br><span class="hljs-comment">/* 本地样式 */</span><br>&lt;/<span class="hljs-selector-tag">style</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="解决方法2：深度作用选择器-gt-gt-gt"><a href="#解决方法2：深度作用选择器-gt-gt-gt" class="headerlink" title="解决方法2：深度作用选择器 &gt;&gt;&gt;"></a>解决方法2：深度作用选择器 &gt;&gt;&gt;</h2><p>如果项目使用的是css 原生样式,那么你可以直接使用 <code>&gt;&gt;&gt;</code> 穿透修改</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less">&lt;<span class="hljs-selector-tag">style</span> <span class="hljs-selector-tag">scoped</span>&gt;<br>  <span class="hljs-selector-class">.a</span> &gt;&gt;&gt; <span class="hljs-selector-class">.b</span> &#123; <br>    <span class="hljs-attribute">color</span>: blue<br>  &#125;<br>&lt;/<span class="hljs-selector-tag">style</span>&gt;<br><br><span class="hljs-comment">/* 上述代码将会编译成： */</span><br><span class="hljs-selector-class">.a</span><span class="hljs-selector-attr">[data-v-469af010]</span> <span class="hljs-selector-class">.b</span> &#123; <span class="hljs-attribute">color</span>: blue &#125;<br></code></pre></td></tr></table></figure><p>有些像sass/less之类的预处理器无法正确解析 <code>&gt;&gt;&gt;</code> ，这时候需要使用 <code>/deep/</code> 选择器，但是vue-cli3可能会导致变异报错。这个时候用 <code>::v-deep</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less">&lt;<span class="hljs-selector-tag">style</span> <span class="hljs-selector-tag">lang</span>=&quot;<span class="hljs-selector-tag">scss</span>&quot; <span class="hljs-selector-tag">scoped</span>&gt;<br>  <span class="hljs-selector-class">.hello</span>&#123;<br>    /<span class="hljs-selector-tag">deep</span>/ <span class="hljs-selector-class">.el-button</span>&#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-selector-class">.hello</span>&#123;<br>    ::<span class="hljs-selector-tag">v-deep</span> <span class="hljs-selector-class">.el-button</span>&#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    &#125;<br>  &#125;<br>&lt;/<span class="hljs-selector-tag">style</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网页模板pug基本语法</title>
    <link href="/2020/07/08/%E7%BD%91%E9%A1%B5%E6%A8%A1%E6%9D%BFpug%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/07/08/%E7%BD%91%E9%A1%B5%E6%A8%A1%E6%9D%BFpug%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="网页模板pug基本语法"><a href="#网页模板pug基本语法" class="headerlink" title="网页模板pug基本语法"></a>网页模板pug基本语法</h1><p>pug原名jade，因版权问题更名为pug，即哈巴狗。与hexo默认模块ejs一样，pug也是一个模板引擎，可用于快速的网站开发，当然也可以用于静态博客网站的设计。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">yarn <span class="hljs-builtin-name">add</span> pug pug-plain-loader<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&#x27;pug&#x27;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 即可 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="基础语法知识"><a href="#基础语法知识" class="headerlink" title="基础语法知识"></a>基础语法知识</h2><p><strong>HTML</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;checkbox&#x27;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>记住密码<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;show-box&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>PUG</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pug">label<br>  input(type=&quot;checkbox&quot;)<br>  span 记住密码<br>  .show-box<br></code></pre></td></tr></table></figure><p>差别有了，惊不惊喜？再来！</p><p><strong>HTML</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login-animate&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left-ear&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right-ear&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left-eye&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right-eye&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;face&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nose&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mouth&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left-arm&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right-arm&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login-form&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pwd-eye&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-image: url(&#x27;img/password-show.png&#x27;);&quot;</span> <span class="hljs-attr">data-flag</span>=<span class="hljs-string">&quot;hide&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>PUG</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pug">.login-animate<br>  .left-ear<br>  .right-ear<br>  .head<br>    .left-eye<br>    .right-eye<br>    .face<br>      .nose<br>      .mouth<br>  .body<br>  .left-arm<br>  .right-arm<br>.login-form<br>  .username<br>    input(type=&quot;text&quot; name=&quot;username&quot;)<br>  .password<br>    input(type=&quot;password&quot; name=&quot;password&quot;)<br>    .pwd-eye<br></code></pre></td></tr></table></figure><p>可以看出代码量明显减少很多。pug不同于html，前者不需要标签的开和闭，如html的<code>&lt;p&gt;Demo&lt;/p&gt;</code>，在pug使用<code>p Demo</code>即可。<br>pug对空格敏感，有点类似python对制表符tab敏感。pug使用空格作为缩进符，当然用soft tab也可行。同一级标签需保证左对齐。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>pug使用 <code>//-</code> 或 <code>//</code> 对代码进行注释，前者注释内容不出现在渲染后的html文件中，后者反之。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pug">//- html中不包含此行<br>//  html中会包含此行<br></code></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>pug将标签属性存放于括号()内，多个属性之间以逗号或空格分隔。此外，对于标签的 <code>id</code> 和 <code>class</code>，pug使用 <code>#</code> 紧跟标签 <code>id</code> ,使用 <code>.</code> 紧跟标签 <code>class</code>，可以同时设置多个 <code>class</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pug">h1#title Test title<br>img#name.class1.class2(src=&quot;/test.png&quot; alt=&quot;test&quot;)<br></code></pre></td></tr></table></figure><p>👇</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Test title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class1 class2&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/test.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><p>为了方便代码复用，pug提供了<code>include</code>包含功能，以下代码会将<code>_partial</code>目录下的<code>head.pug</code>文件内容包含到当前调用的位置。有点<code>C/C++</code>中内联函数的意思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pug">doctype html<br>html(lang=&#x27;en&#x27;)<br>  include _partial/head.pug<br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>下面是一个简单的base模板，通过block定义了页面头部head和内容body。块block有点类似C/C++的抽象函数，需要在继承者中完成定义，填充具体内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pug">//- base.pug<br>html<br>  head<br>    block title<br>  body<br>    block content<br><br></code></pre></td></tr></table></figure><p>以下文件使用extends继承以上模板，通过block覆盖或替换原有块block。当然，继承者也可以在原有基础上继续扩展。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pug"><br>//- index.pug<br>extends base.pug<br><br>block title<br>  title &quot;Test title&quot;<br><br>block content<br>  h1 Hello world!<br>  block article<br></code></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>pug中通过 <code>- var name = value</code> 的形式定义变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pug">- var intData = 100<br>- var boolData = false<br>- var stringData = &#x27;Test&#x27;<br>p.int = intData<br>p.bool = boolData<br>p.stringData = stringData<br></code></pre></td></tr></table></figure><p>需注意的是，在引用变量时需要在引用位置加上<code>=</code>号，否则会默认将变量名当成普通字符串使用。</p><p>如果想要将变量与其它字符串常量或是变量连接在一起，就不能用等号了，而是应该用<code>#&#123;&#125;</code>，该符号会对大括号内的变量进行求值和转义，最终得到渲染输出的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pug">- var girl = &#x27;Lily&#x27;<br>- var boy = &#x27;Jack&#x27;<br>p #&#123;girl&#125; is so beautiful!<br>p And #&#123;boy&#125; is handsome.<br></code></pre></td></tr></table></figure><h3 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h3><p>pug的条件语句与其它语言类似，均是如下这般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pug">- var array = [1, 2]<br>  if array.length &gt; 2<br>    p true<br>  else<br>    p false<br></code></pre></td></tr></table></figure><p>unless 为false，才执行，用法与if类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pug">- var array = [1, 2]<br>  unless  !istrue<br>    p hello<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pug">-var name = &#x27;java&#x27;<br>case name<br>  when &#x27;java&#x27;: p Hi, java<br>case name<br>  when &#x27;pug&#x27;: p Hi, pug<br>default<br>  p Hi<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript交换两个变量的值</title>
    <link href="/2020/07/07/javascript%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/"/>
    <url>/2020/07/07/javascript%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript优雅地交换两个变量的值"><a href="#JavaScript优雅地交换两个变量的值" class="headerlink" title="JavaScript优雅地交换两个变量的值"></a>JavaScript优雅地交换两个变量的值</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>最最最简单的办法就是使用一个临时变量了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> temp;<br>temp = a;<br>a = b;<br>b = temp;<br></code></pre></td></tr></table></figure><p>不过使用临时变量的方法实在是太low了，我们试试如何用一行代码不使用临时变量来交换a，b两个变量的值</p><p>首先最简单的，最流氓的暴力写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`a = <span class="hljs-subst">$&#123;b&#125;</span>, b = <span class="hljs-subst">$&#123;a&#125;</span>`</span>)<br></code></pre></td></tr></table></figure><p>皮一下，下面是正经写法 下面的方案都不会有临时变量，我总结了一下，其实不使用临时变量的思路都是让其中一个变量变成一个a和b都有关系的值，这样可以先改变另一个变量值， 最后改变原修改的变量值</p><h3 id="1-加法运算"><a href="#1-加法运算" class="headerlink" title="1.加法运算"></a>1.加法运算</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">b = <span class="hljs-comment">(a + b)</span> - <span class="hljs-comment">(a = b)</span><br></code></pre></td></tr></table></figure><p>（也可以换成a和b的差，一样的）不过上面这个方法有个明显的缺点就是有可能溢出</p><h3 id="2-运算优先级"><a href="#2-运算优先级" class="headerlink" title="2.运算优先级"></a>2.运算优先级</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">b = a + <span class="hljs-number">0</span> \* <span class="hljs-comment">(a = b)</span><br></code></pre></td></tr></table></figure><h3 id="3-异或位运算操作"><a href="#3-异或位运算操作" class="headerlink" title="3.异或位运算操作"></a>3.异或位运算操作</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">a</span><span class="hljs-regexp"> ^=</span> b<span class="hljs-regexp"> ^</span> (b = a)<br></code></pre></td></tr></table></figure><h3 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> = <span class="hljs-selector-attr">[b, b = a]</span><span class="hljs-selector-attr">[0]</span><br></code></pre></td></tr></table></figure><h3 id="5-ES6解构赋值"><a href="#5-ES6解构赋值" class="headerlink" title="5.ES6解构赋值"></a>5.ES6解构赋值</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[a, b]</span> = <span class="hljs-comment">[b, a]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 语法「可选链」「双问号」</title>
    <link href="/2019/08/22/js-%E8%AF%AD%E6%B3%95%E3%80%8C%E5%8F%AF%E9%80%89%E9%93%BE%E3%80%8D%E3%80%8C%E5%8F%8C%E9%97%AE%E5%8F%B7%E3%80%8D/"/>
    <url>/2019/08/22/js-%E8%AF%AD%E6%B3%95%E3%80%8C%E5%8F%AF%E9%80%89%E9%93%BE%E3%80%8D%E3%80%8C%E5%8F%8C%E9%97%AE%E5%8F%B7%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="JS-语法「可选链」「双问号」"><a href="#JS-语法「可选链」「双问号」" class="headerlink" title="JS 语法「可选链」「双问号」"></a>JS 语法「可选链」「双问号」</h1><p>你可能写过这样的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> street = user.address &amp;&amp; user.address.street;<br></code></pre></td></tr></table></figure><p>有了这个语法，你可以写成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> street = user.address?.street<br></code></pre></td></tr></table></figure><p>你可能还写过这样的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fooInput = myForm.querySelector(<span class="hljs-string">&#x27;input[name=foo]&#x27;</span>)<br><span class="hljs-keyword">var</span> fooValue = fooInput ? fooInput.value : <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>有了语法后，你可以写成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fooValue = myForm.querySelector(<span class="hljs-string">&#x27;input[name=foo]&#x27;</span>)?.value<br></code></pre></td></tr></table></figure><p>但在实际使用中，还是会有些不便，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = response?.settings?.n || <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>你希望如果 response 或者 response.settings 或者 response.settings.n 不存在（值为 null 或者 undefined）时，result 保底值为 100。</p><p>但是上面代码在 n 为 0 的时候，也会让 result 变成 100，你实际上希望此时 result 为 0。</p><p>于是你只好把代码写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = response?.settings?.n === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">100</span> : response?.settings?.n<br></code></pre></td></tr></table></figure><p>或者你封装一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = fetch(response?.settings?.n, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>现在，你可以用另一个语法——「双问号语法」——来简化代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = response?.settings?.n ?? <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>这个 ?? 的意思是，如果 ?? 左边的值是 null 或者 undefined，那么就返回右边的值。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 css 和 svg 绘制一朵“真实”的云</title>
    <link href="/2019/07/02/%E7%94%A8css%E5%92%8Csvg%E7%BB%98%E5%88%B6%E4%B8%80%E6%9C%B5%E7%9C%9F%E5%AE%9E%E7%9A%84%E4%BA%91/"/>
    <url>/2019/07/02/%E7%94%A8css%E5%92%8Csvg%E7%BB%98%E5%88%B6%E4%B8%80%E6%9C%B5%E7%9C%9F%E5%AE%9E%E7%9A%84%E4%BA%91/</url>
    
    <content type="html"><![CDATA[<h1 id="用-css-和-svg-绘制一朵“真实”的云"><a href="#用-css-和-svg-绘制一朵“真实”的云" class="headerlink" title="用 css 和 svg 绘制一朵“真实”的云"></a>用 css 和 svg 绘制一朵“真实”的云</h1><p><strong>本文根据文章 <a href="https://css-tricks.com/drawing-realistic-clouds-with-svg-and-css/">Drawing Realistic Clouds with SVG and CSS</a>，仅记录自己学习过程。</strong></p><h3 id="最终实现效果："><a href="#最终实现效果：" class="headerlink" title="最终实现效果："></a>最终实现效果：</h3><p><img src="/img/blog/css-svg-cloud.png"></p><p>首先，CSS的box-shadow属性有五个值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-attribute">box-shadow</span>: &lt;offsetX&gt; &lt;offsetY&gt; &lt;blurRadius&gt; &lt;spreadRadius&gt; &lt;color&gt;;<br></code></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>h-shadow</td><td>必需。水平阴影的位置。允许负值。</td></tr><tr><td>v-shadow</td><td>必需。垂直阴影的位置。允许负值。</td></tr><tr><td>blur</td><td>可选。模糊距离。</td></tr><tr><td>spread</td><td>可选。阴影的尺寸。</td></tr><tr><td>color</td><td>可选。阴影的颜色。</td></tr><tr><td>inset</td><td>可选。将外部阴影 (outset) 改为内部阴影。</td></tr></tbody></table><p>我们把这些值调高，就会得到类似影子木偶的效果：</p><p><img src="/img/blog/css-svg-cloud-demo1.png"></p><p><img src="/img/blog/css-svg-cloud-demo2.png"></p><p>就像一只手改变形状可以改变投影一样，我们改变HTML的“源形状”也可以使渲染在浏览器中的投影变形。<code>box-shadow</code>复制了原始尺寸和<code>border-radius</code>上的“渐变”特性，SVG过滤器则同时应用于元素及其阴影。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;filter&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feTurbulence</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;fractalNoise&quot;</span> <span class="hljs-attr">baseFrequency</span>=<span class="hljs-string">&quot;.01&quot;</span> <span class="hljs-attr">numOctaves</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feDisplacementMap</span> <span class="hljs-attr">in</span>=<span class="hljs-string">&quot;SourceGraphic&quot;</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是我们目前的SVG代码，它不会被渲染，因为我们还没有定义任何可见的东西。它唯一的目的就是保存我们为<code>SourceGraphic</code>（也就是我们的<code>&lt;div&gt;</code>）提供的过滤器。</p><p>借助SVG过滤器的ID，通过添加CSS规则将HTML元素 #cloud-circle 和SVG过滤器进行关联：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-id">#cloud-circle</span> &#123;<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">#filter</span>);<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span> <span class="hljs-number">50px</span> <span class="hljs-number">0px</span> <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>差不多就是这样：</strong></p><p><img src="/img/blog/css-svg-cloud-demo3.png"></p><h2 id="尝试使用feDisplacementMap的scale属性"><a href="#尝试使用feDisplacementMap的scale属性" class="headerlink" title="尝试使用feDisplacementMap的scale属性"></a>尝试使用feDisplacementMap的scale属性</h2><p>使用这一属性进行一些非科学试验可以产生显著的效果。现在，我们保持<code>feTurbulence</code>的值不变，简单调整<code>feDisplacementMap</code>的<code>scale</code>属性值。</p><p>随着<code>scale</code>的增加（以30为增量），我们的源<code>&lt;div&gt;</code>变得扭曲，投射的阴影反应出天空中云出现的随机形式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">feDisplacementMap</span> <span class="hljs-attr">in</span>=<span class="hljs-string">&quot;SourceGraphic&quot;</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;180&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/blog/css-svg-cloud-demo4.png"></p><p>好了，我们有进展了！让我们稍微改变颜色，以形成更具说服力的云。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">165deg</span>, <span class="hljs-number">#527785</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#7FB4C7</span> <span class="hljs-number">100%</span>);<br>&#125;<br><br><span class="hljs-selector-id">#cloud-circle</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">180px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">180px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">#filter</span>);<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span> <span class="hljs-number">50px</span> <span class="hljs-number">0px</span> <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/blog/css-svg-cloud-demo5.png"></p><h2 id="修改box-shadow的模糊度"><a href="#修改box-shadow的模糊度" class="headerlink" title="修改box-shadow的模糊度"></a>修改box-shadow的模糊度</h2><p>下面一套图片展示了<code>box-shadow</code>属性的模糊度作用的效果，这里，我们以10px递增模糊值：</p><p><img src="/img/blog/css-svg-cloud-demo6.png"></p><center style="font-size:14px;color:#C0C0C0;">随着模糊值增加，云朵也变得更加柔和。</center><br><p>为了增加一点积云的效果，我们可以稍微扩宽源<code>&lt;div&gt;</code>的宽度：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-id">#cloud-circle</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; <br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">275px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">#filter</span>);<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span> <span class="hljs-number">60px</span> <span class="hljs-number">0px</span> <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/blog/css-svg-cloud-demo7.png"></p><p>等等，我们扩宽了源元素的宽度，但它现在遮挡在我们云层（白色阴影）的上方。让我们在更远的位置重新投影，这样我们的云就不会再被源图像遮挡了（你可以想象成把你的手往远离墙的方向移动，这样它就不会挡住你的影子木偶的视线了）。</p><p>这点我们通过CSS定位可以很好地实现。<code>&lt;body&gt;</code>是父元素，默认是静态定位的，我们给源<code>&lt;div&gt;</code>添加绝对定位。最初地，这也会重新定位我们的阴影，因此我们还需要增加阴影和元素之间的距离。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-id">#cloud-circle</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">275px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">#filter</span>);<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">400px</span> <span class="hljs-number">400px</span> <span class="hljs-number">60px</span> <span class="hljs-number">0px</span> <span class="hljs-number">#fff</span>; <span class="hljs-comment">/* 增加投影位移 */</span><br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: -<span class="hljs-number">320px</span>;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">320px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们已经实现了一个极具说服力的云</p><p><img src="/img/blog/css-svg-cloud-demo8.png"></p><h2 id="通过层次传达深度"><a href="#通过层次传达深度" class="headerlink" title="通过层次传达深度"></a>通过层次传达深度</h2><p>这是我们想要的效果：</p><p><img src="/img/blog/css-svg-cloud-demo9.png"></p><p>从这张照片中云层的深度、纹理和丰富性来看，宙斯一定是读过艺术专业的。至少，他一定读过《通用设计法则》，这本书阐述了一个强大而又普通的概念：<code>照明偏差在深度和自然度的解释中起着重要作用，设计师可以通过多种方式操纵照明偏差，利用明暗区域之间的对比度来改变深度的外观。</code></p><p>这段话给了我们一个提示，我们可以将不同形状、大小和颜色的图层堆叠在一起，可以实现像参考图片中那样具有高保真度的云。我们要做的也只是多次调用SVG过滤器。</p><p><img src="/img/blog/css-svg-cloud-demo10.png"></p><p> 使用三个SVG过滤器绘制前中后三朵云：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 后层 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;filter-back&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feTurbulence</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;fractalNoise&quot;</span> <span class="hljs-attr">baseFrequency</span>=<span class="hljs-string">&quot;0.012&quot;</span> <span class="hljs-attr">numOctaves</span>=<span class="hljs-string">&quot;4&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feDisplacementMap</span>  <span class="hljs-attr">in</span>=<span class="hljs-string">&quot;SourceGraphic&quot;</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;170&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 中层 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;filter-mid&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feTurbulence</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;fractalNoise&quot;</span> <span class="hljs-attr">baseFrequency</span>=<span class="hljs-string">&quot;0.012&quot;</span> <span class="hljs-attr">numOctaves</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feDisplacementMap</span>  <span class="hljs-attr">in</span>=<span class="hljs-string">&quot;SourceGraphic&quot;</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;150&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 前层 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;filter-front&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feTurbulence</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;fractalNoise&quot;</span> <span class="hljs-attr">baseFrequency</span>=<span class="hljs-string">&quot;0.012&quot;</span> <span class="hljs-attr">numOctaves</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">feDisplacementMap</span>  <span class="hljs-attr">in</span>=<span class="hljs-string">&quot;SourceGraphic&quot;</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">&quot;100&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过分层的应用，我们有机会去探索feTurbulence并认识它的多样性。我们选择了较为平滑的类型：fractalNoise，对于numOctaves的值最高只调到了6。</p><p>上面这些意味着什么？我们来看一下baseFrequency这个属性，下面几张图片是不同baseFrequency值下的效果。</p><p><img src="/img/blog/css-svg-cloud-demo11.png"></p><center style="font-size:14px;color:#C0C0C0;">值越低，图像就越圆，越模糊。</center><br><p>从效果看，介于0.005~0.01的值比较符合我们想要的积云效果。</p><h2 id="用numOctaves添加细节。"><a href="#用numOctaves添加细节。" class="headerlink" title="用numOctaves添加细节。"></a>用numOctaves添加细节。</h2><p>增加numOctaves值允许我们以更细的粒度去渲染图像，这个过程需要大量的计算，因此需要注意：高值会严重影响性能。</p><p><img src="/img/blog/css-svg-cloud-demo12.png"></p><center style="font-size:14px;color:#C0C0C0;">numOctaves的值设置得越高，云的效果就越精细。</center><br><p>我们不需要为达到精细的效果而设置太高的值，介于4~5就够了。</p><p><a href="https://blog.zhchi.me/amazing-css/cloud-css/index.html">最后的效果 </a> </p><p><img src="/img/blog/css-svg-cloud.png"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>SVG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当position：fixed 遇上transform：translate</title>
    <link href="/2018/10/22/%E5%BD%93positionfixed%E9%81%87%E4%B8%8Atransform-translate/"/>
    <url>/2018/10/22/%E5%BD%93positionfixed%E9%81%87%E4%B8%8Atransform-translate/</url>
    
    <content type="html"><![CDATA[<h1 id="当position：fixed-遇上transform：translate"><a href="#当position：fixed-遇上transform：translate" class="headerlink" title="当position：fixed 遇上transform：translate"></a>当position：fixed 遇上transform：translate</h1><p>大家都知道 position: fixed 在日常的页面布局中非常常用，在许多布局中起到了关键的作用。它的作用是：<code>position: fixed 的元素将相对于屏幕视口（viewport）的位置来指定其位置。并且元素的位置在屏幕滚动时不会改变。</code></p><p>但是在许多特定的场合，指定了 position: fixed 的元素却无法相对于屏幕视口进行定位。这是为何呢？</p><p>在许多情况下， position: fixed 将会失效。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">MDN</a>用一句话概括了这种情况：</p><blockquote><p><strong>当元素祖先的 transform 属性非 none 时，定位容器由视口改为该祖先。</strong></p></blockquote><br><p>What！还有这种操作？可能有部分同学还没 get 到上面这句话的意思，通俗的讲就是指定了 position: fixed 的元素，如果其祖先元素存在非 none 的 transform 值 ，那么该元素将相对于设定了 transform 的祖先元素进行定位。 那么，为什么会发生这种情况呢？说好的相对视口（Viewport）定位呢？ 这个问题，就牵涉到了 Stacking Context ，也就是堆叠上下文的概念了。解释上面的问题分为两步：</p><ol><li>任何非 none 的 transform 值都会导致一个堆叠上下文（Stacking Context）和包含块（Containing Block）的创建。</li><li>由于堆叠上下文的创建，该元素会影响其子元素的固定定位。设置了 position:fixed 的子元素将不会基于 viewport 定位，而是基于这个父元素。</li></ol><h2 id="Stacking-Context-–-堆叠上下文"><a href="#Stacking-Context-–-堆叠上下文" class="headerlink" title="Stacking Context – 堆叠上下文"></a>Stacking Context – 堆叠上下文</h2><p>好的嘛，好的嘛，又冒出新的名词了，堆叠上下文（又译作层叠上下文），又是什么？</p><p><strong>堆叠上下文</strong>（Stacking Context）：堆叠上下文是 HTML 元素的三维概念，这些 HTML 元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的 z 轴上延伸，HTML 元素依据其自身属性按照优先级顺序占用层叠上下文的空间。</p><p>概念比较抽象，简单理解，记住 生成了 Stacking Context 的元素会影响该元素的层叠关系与定位关系。</p><p>而本文提到了生成了 Stacking Context 的元素会影响该元素定位关系。按照上面的说法，堆叠上下文的创建，该元素会影响其子元素的固定定位。设置了position:fixed 的子元素将不会基于 viewport 定位，而是基于这个父元素。</p><p>那么问题来了，是否所有能够生成堆叠上下文的元素，都会使得其子元素的 position:fixed 相对它，而不是相对视口（Viewport）进行定位呢？</p><h2 id="创建堆叠上下文的方式"><a href="#创建堆叠上下文的方式" class="headerlink" title="创建堆叠上下文的方式"></a>创建堆叠上下文的方式</h2><p>为此，首先要找到所有能够使元素生成堆叠上下文的方法。</p><p>So，如何触发一个元素形成堆叠上下文？方法如下（参考自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context">MDN</a>）：</p><ol><li>根元素 (HTML)</li><li>z-index 值不为 “auto” 的 绝对/相对定位</li><li>一个 z-index 值不为 “auto” 的 flex 项目 (flex item)，即：父元素 display: flexinline-flex;</li><li>opacity 属性值小于 1 的元素（参考 the specification for opacity）</li><li>transform 属性值不为 “none” 的元素</li><li>mix-blend-mode 属性值不为 “normal” 的元素</li><li>filter值不为 “none” 的元素</li><li>perspective值不为 “none” 的元素</li><li>isolation 属性被设置为 “isolate” 的元素</li><li>position: fixed</li><li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值</li><li>webkit-overflow-scrolling 属性被设置 “touch” 的元素</li></ol><h2 id="一探-position-fixed-失效的最终原因"><a href="#一探-position-fixed-失效的最终原因" class="headerlink" title="一探 position:fixed 失效的最终原因"></a>一探 position:fixed 失效的最终原因</h2><p>通过上面的试验，在最新的 Blink 内核下，发现并不是所有能够生成层叠上下文的元素都会使得 position: fixed 失效，但也不止 transform 会使 position: fixed 失效。</p><p>所以，MDN 关于 position: fixed 的补充描述不够完善。下述 3 种方式目前都会使得 position: fixed 定位的基准元素改变（本文重点）：</p><ol><li>transform 属性值不为 none 的元素</li><li>perspective 值不为 none 的元素</li><li>在 will-change 中指定了任意 CSS 属性</li></ol><h2 id="不同内核的不同表现"><a href="#不同内核的不同表现" class="headerlink" title="不同内核的不同表现"></a>不同内核的不同表现</h2><p>完了吗？没有！我们再看看其他内核下的表现：</p><p>上面也谈到了，上述结论是在最新的 Chrome 浏览器下（Blink内核），经过测试发现，在 MAC 下的 Safari 浏览器（WebKit内核，Version 9.1.2 (11601.7.7)）和 IE Trident/ 内核及 Edge 浏览器下，上述三种方式都不会改变 position: fixed 的表现！</p><p>所以，当遇到 position: fixed 定位基准元素改变的时候，需要具体问题具体分析，多尝试一下，根据需要兼容适配的浏览器作出调整，不能一概而论。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>Stacking-Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0.1+0.2=?</title>
    <link href="/2018/09/19/js-0.1+0.2/"/>
    <url>/2018/09/19/js-0.1+0.2/</url>
    
    <content type="html"><![CDATA[<h1 id="0-1-0-2"><a href="#0-1-0-2" class="headerlink" title="0.1+0.2=?"></a>0.1+0.2=?</h1><p>相信写过程序的人都知道，0.1+0.2≠0.3，而是等于0.30000000000000004，类似的还有 0.7×180=125.99999999998，1000000000000000128 ===1000000000000000129。</p><p>虽然很久之前就知道这个结果，也知道该怎么去做，但是一直没有去深究其中的原因，今天来复习一下其中的相关知识，顺便做个笔记。</p><p>众所周知 JS 仅有 Number 这个数值类型，而 Number 采用的是 IEEE 754 64位双精度浮点数编码。这是一个什么样的标准呢？使用这个标准的 64-bits 双精度意味着什么？所以，要掌握 JavaScript 中的数字，我们首先得了解 IEEE 754标准。下面，我将尝试说明一下这个标准，为我们最后学习 JavaScript 中的数字做铺垫。</p><p>当下，计算机如此普及，我相信，即便非程序员也了解：计算机的世界只有 0 和 1。而一个程序员应该了解：0 / 1 组成的东西叫机器码，有原码, 反码, 补码等。而一个 JS 程序员应该了解：JS 中的数字是不分类型的，也就是没有 byte / int / float / double等的差异。而一个稍微研究 ES 规范的 JS 程序员应该了解：JS 的 number 是 IEEE 754标准下 64-bits 的双精度数值，而且 ES 中有 ToInteger / ToInt32 / ToUint32 / ToUint16 等 Type Conversion。下面，我们就尝试着讨论一下这些。</p><p>从硬件的角度上讲，维护两个状态是相对容易的，比如一个二极管的导通或者截止，一个电脉冲的高或者低，从而在实现集成电路时候可以更加简单高效，所以计算机普遍使用 0 和 1 来存储和计算。那么，只有 0 和 1，如何表示 1234567890 呢？这就涉及到 <strong>机器码</strong> 和 <strong>真值</strong>。</p><h2 id="机器码和真值"><a href="#机器码和真值" class="headerlink" title="机器码和真值"></a>机器码和真值</h2><p>所谓 <strong>机器码</strong> 是指，整数在计算机中二进制形式。规则很简单，机器码的最高位（左第一位）表示数字的正负，0 表示正数，1 表示负数，其余位按照进制转换的规则表示具体数字。</p><p>所谓 <strong>真值</strong> 是指，机器码按照上述转换规则还原的带有正负的实际整数。</p><p>举例而言，用 8-bits 表示一个整数，则十进制的整数 +6 可表示为：00000110；十进制的数字 -5 可表示为 10000101。这里说的 +6 和 -5 便是 <strong>真值</strong>，而表示它们的二进制数便是 <strong>机器码</strong>。再次注意，最高位只用于表示正负，比如 10000101 的真值是 -5 而非 133，以及我们关于机器码和真值的讨论是基于整数范围的，浮点数在计算机中的存储方式与整数有很大差值，将另作讨论。</p><p>有了机器码，我们便可以在计算机中使用机器码存储和计算真值，那么机器码在计算机中是如何计算的呢？</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>机器码分为多种，主要包括原码、反码、补码、移码等，今天我们主要总结一下前三个，而移码非常简单，且多用于比较，不做详细说明。另外需要补充一点，我们在此区分机器码的这么多种形式，主要是针对的有符号数，而无符号数，不需要使用最高位来表示正负，也就不需要这么多种编码方式。</p><p><strong>原码：</strong></p><p>最高位表示正负，其它位表示真值的绝对值。其中，最高位为0表示正数或者0，为1表示负数。</p><p>比如，同样以 8bits 长度的数串表示 +7 的原码为 00000111，-7 的原码为 10000111。以后，我们会这样表示：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[+7]</span> = <span class="hljs-comment">[00000111]</span>原<br><span class="hljs-comment">[-7]</span> = <span class="hljs-comment">[10000111]</span>原<br></code></pre></td></tr></table></figure><p>很明显，8-bits 的原码能记录的范围为：[-127, +127]。</p><p>原码的好处在于，易于理解，相对直观，方便人脑识别和计算。</p><p>对于原码，人脑使用，可以直接计算出其真值然后可以进行后续操作。<strong>但对于计算机，首先，因为最高位用于表示正负，所以不能直接参与运算，需要识别然后做特殊处理；其次，具体计算使用绝对值进行操作，所以两个操作数正负的异同会影响操作符，比如两个异号相加实际要做减法操作，甚至异号相减还需要判断绝对值大小然后决定结果正负。如此，我们计算机的运算器设计将会变得异常复杂。下面，我们将了解如何使用反码和补码将符号位参与运算，从而使加减法统一简单高效地处理，这也是反码和补码出现的原因。</strong></p><p><strong>反码：</strong></p><p>正数的反码等于其原码，而负数的反码则是对其原码进行符号位不变，其它位逐一取反的结果。</p><p>比如，同样以 8-bits 长度的数串表示 +7，那么有如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[+7]</span> = <span class="hljs-comment">[00000111]</span>原 = <span class="hljs-comment">[00000111]</span>反<br><span class="hljs-comment">[-7]</span> = <span class="hljs-comment">[10000111]</span>原 = <span class="hljs-comment">[11111000]</span>反<br></code></pre></td></tr></table></figure><p>同样，8-bits的反码能记录的范围为：[-127, +127]。</p><p>在按位取反之后，我们可以有下面的操作：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2</span> - <span class="hljs-number">3</span> = <span class="hljs-number">2</span> + (-<span class="hljs-number">3</span>)<br>      = [<span class="hljs-number">00000010</span>]原 + [<span class="hljs-number">10000011</span>]原<br>      = [<span class="hljs-number">00000010</span>]反 + [<span class="hljs-number">11111100</span>]反<br>      = [<span class="hljs-number">11111110</span>]反 = [<span class="hljs-number">10000001</span>]原<br>      = -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>上面，我们将减法通过反码转化为了加法，如此，我们的运算将会简单很多，但是反码的方式同样存在一些问题：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">3</span> - <span class="hljs-number">3</span> = <span class="hljs-number">3</span> + (-<span class="hljs-number">3</span>)<br>      = [<span class="hljs-number">00000011</span>]原 + [<span class="hljs-number">10000011</span>]原<br>      = [<span class="hljs-number">00000011</span>]反 + [<span class="hljs-number">11111100</span>]反<br>      = [<span class="hljs-number">11111111</span>]反<br>      = [<span class="hljs-number">10000000</span>]原<br>      = -<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>出现了 -0，这个值是没有意义的。另外，<strong>按照反码加法法则，如果最高位有进位，需要在最低位上+1</strong>，那么会出现：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">3</span> - <span class="hljs-number">2</span> = <span class="hljs-number">3</span> + (-<span class="hljs-number">2</span>)<br>      = [<span class="hljs-number">00000011</span>]原 + [<span class="hljs-number">10000010</span>]原<br>      = [<span class="hljs-number">00000011</span>]反 + [<span class="hljs-number">11111101</span>]反 (这里最高位有进位，需要在最低位+<span class="hljs-number">1</span>)<br>      = [<span class="hljs-number">00000001</span>]反<br>      = [<span class="hljs-number">00000001</span>]原 = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这种情况，又增加了反码运算的复杂性，影响效率，为解决上面的问题，出现了补码。</p><p><strong>补码：</strong></p><p>正数的反码等于其原码，而负数的补码则是对其反码进行末位加 1 的结果。</p><p>比如，再同样以 8-bits 长度的数串表示 +7，那么有如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[+7]</span> = <span class="hljs-comment">[00000111]</span>原 = <span class="hljs-comment">[00000111]</span>反 = <span class="hljs-comment">[00000111]</span>补<br><span class="hljs-comment">[-7]</span> = <span class="hljs-comment">[10000111]</span>原 = <span class="hljs-comment">[11111000]</span>反 = <span class="hljs-comment">[11111001]</span>补<br></code></pre></td></tr></table></figure><p>使用补码，继续做之前的操作：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2</span> - <span class="hljs-number">3</span> = <span class="hljs-number">2</span> + (-<span class="hljs-number">3</span>)<br>      = [<span class="hljs-number">00000010</span>]原 + [<span class="hljs-number">10000011</span>]原<br>      = [<span class="hljs-number">00000010</span>]反 + [<span class="hljs-number">11111100</span>]反<br>      = [<span class="hljs-number">00000010</span>]补 + [<span class="hljs-number">11111101</span>]补<br>      = [<span class="hljs-number">11111111</span>]补<br>      = [<span class="hljs-number">11111110</span>]反<br>      = [<span class="hljs-number">10000001</span>]原<br>      = -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>那么，如果是 3-3 呢？</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">3</span> - <span class="hljs-number">3</span> = <span class="hljs-number">3</span> + (-<span class="hljs-number">3</span>)<br>      = [<span class="hljs-number">00000011</span>]原 + [<span class="hljs-number">10000011</span>]原<br>      = [<span class="hljs-number">00000011</span>]反 + [<span class="hljs-number">11111100</span>]反<br>      = [<span class="hljs-number">00000011</span>]补 + [<span class="hljs-number">11111101</span>]补<br>      = [<span class="hljs-number">00000000</span>]补<br>      = [<span class="hljs-number">00000000</span>]原<br>      = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>是否还需要做额外的加法操作？</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">3</span> - <span class="hljs-number">2</span> = <span class="hljs-number">3</span> + (-<span class="hljs-number">2</span>)<br>      = [<span class="hljs-number">00000011</span>]原 + [<span class="hljs-number">10000010</span>]原<br>      = [<span class="hljs-number">00000011</span>]反 + [<span class="hljs-number">11111101</span>]反<br>      = [<span class="hljs-number">00000011</span>]补 + [<span class="hljs-number">11111110</span>]补<br>      = [<span class="hljs-number">00000001</span>]补<br>      = [<span class="hljs-number">00000001</span>]原<br>      = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这样，我们便可以完美的将减法统一到加法之上，而且不需要繁琐的正负判断，进位控制，甚至可以节约一个位置。那么，这个位置，也就是 10000000 如何处理呢？按照规定，10000000 用来表示 -128，正数的补码 / 反码 / 原码相同，而负数的补码只是占用了 -0 的 [10000000] 原和 [11111111] 反转换后得到的 [10000000] 补表示 -128，但是这个只是帮助理解，不能反向回推得到 -128的原码和补码。</p><p>所以，8bits的补码能记录的范围为：[-128, +127]。</p><p>至此，我们已经了解了，计算机中主要使用的存储和计算整数的方式，鉴于现代计算机主要使用补码方式，自然能很容易理解各种数字类型的表示范围。这对于我们后面理解一些 JavaScript 中的极端情况至关重要。</p><h2 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h2><p><strong>标准的基本原理：</strong></p><p>我们知道，对于计算机而言，数字没有小数和整数的差别，也就是计算机中没有小数点的存在。虽然我们已经找到了很完美的整数存储计算的方案，但是当涉及到小数，我们很容易发现，现有的方案无法解决我们的需求。然后，计算机科学家们便尝试了多种方案，主要便是 <strong>定点数</strong> 和 <strong>浮点数</strong> 两种。</p><p>所谓定点数，是指小数点位置固定在数串中间的某个特定位置，点两侧分别为数字的整数和小数部分。比如用 8-bits 字长的数串，小数点固定在正中间位置，那么<code>11001001</code>和<code>00110101</code>分别表示 1100.1001 和 11.0101 两个数字。这种方案简单直观易理解，但是存在严重的空间浪费，以及容易溢出的问题。</p><p>所谓浮点数，是指小数点的位置是不固定的，通过科学计数法（这个应该不需要解释吧）的方式控制小数点的位置，表示不同的数字。这个表示方案便是<code>IEEE 754标准</code>使用的方案。<code>IEEE 754标准</code>是目前使用最广泛的浮点数运算标准。下面我们将主要讨论一下此方案。</p><p>现在，让我们想一下小时候学习的科学计数法，比如 -123.456 这个数字，转换成科学计数法应该是：-1.23456 × 10^2。这里面已经包含了<code>IEEE 754标准</code>的主要元素。我们梳理一下：第一个，自然是正负号的问题，需要一个标志；然后，需要一个具体的数字，表示有效数字或者精度，如上例的 1.23456；再然后，需要一个控制小数点位置的数字，如上例的 10^2，回忆一下，我们学习科学计数法的时候，要求前面的数字的绝对值大于 1 而小于 10，也就是小于 10^2 中的<code>底数(Base)</code>，进制固定之后，底数应该是固定的，所以这里起决定作用的是指数，也就是上例中的 2。那么，有了这三个元素，我们便可以很轻松的表示出一个数字，并且灵活的调节小数点位置从而控制数字正负、精度和大小。</p><p>上面的要素，转换成标准语言描述，我们称表示正负的标志叫 <strong>符号（Sign）</strong>，表示精度的数字为 <strong>尾数（Mantissa）</strong>或者 <strong>有效数字（Significand）</strong>，而控制小数点位置的指数就叫 <strong>指数（Exponent）</strong>，指数和 <strong>基数（Base）</strong>共同作用参与计算。下图取自wikipedia，我们直观地感受下这三个要素在一个数串中的相对关系（fraction区域即等同于前面说的有效数字区域）：</p><p><img src="/img/blog/0102-demo1.png"></p><p>了解最基本的原理后，我们来大致看一下<code>IEEE 754标准</code>做了什么。</p><p>首先做的事情就是规定这三个要素在一个数串中占有的位数，试想一下，如果各个实现的位数不确定，那么我们是不是很难正确的还原出原始数字？<code>IEEE 754标准</code>规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80比特实做）。只有32位模式有强制要求，其他都是选择性的。而现在主流的语言，多提供了单精度和双精度的实现，我们在此主要比较一下这两者，如图是它们各个部分对应上图，所使用的位数如下：</p><p><img src="/img/blog/0102-demo2.jpg"></p><p>补充一点的是，无论是科学计数法还是标准的规定，都要求有效数字（不考虑符号位）必须 <code>&gt;=1 &amp;&amp; &lt;Base</code>。所以，有效数字其实是一个定点数，小数点的位置固定在有效数字域的最高位和次高位之间。那么，按照上述规定，在二进制中，最高位只能是 1，所以标准要求省略其最高位，于是精度提高一位。比如，32-bits 的单精度有效数字区域只有 23 位，但是精度却是24位；64-bits 的双精度，拥有 52 位的有效数字域却是 54 位精度的。</p><p>然后，还有一个问题，如果按照先有的约定，是不是无法表示小于 1 的实数？因为，指数一定 <code>&gt;=0</code>，有效数字一定 <code>&gt;1</code>。于是，<code>IEEE 754标准</code> 提出了一个很重要的 <strong>指数偏移值</strong>。它是说明指数域(Exponent占用的区域)的编码值为指数的实际值加上某个固定的值，换言之便是，如果我们根据指数域计算出的指数是N，那么参与计算实际浮点数的指数应该是<code>N-指数偏移值</code>。根据IEEE 754标准的规定，该固定值为 2^(e-1) - 1，其中的 e 为存储指数的比特的长度。比如，从上图中我们看到，32-bits 的单精度是以 8-bits 表示一个指数域，那么偏移值应该是 2^(8-1) - 1 = 128−1 = 127。所以，容易得出，单精度浮点数的指数部分实际取值是[-127, 128]。比如，某个 32-bits 单精度的指数为十进制的 1，那么指数域的编码应该是<code>10000001</code>，某个 32-bits 单精度的指数域编码是<code>00000001</code>，那么该指数的实际值应该是十进制的 -126。这样，我们就能通过偏移值将正指数转换为负指数，从而使浮点数能逼近 0。浮点数的指数计算跟前面讨论的机器码恰好相反，正数的最高位都是 1，而负数的最高位都是 0。 以上的描述，便是<code>IEEE 754标准</code>最需要我们了解的原理部分，但是，作为一个广泛使用的工业标准，规定这些还是远远不够的。</p><p><strong>稍加补充：</strong></p><p>wikipedia对<code>IEEE 754标准</code>有如下描述：</p><p>这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number）），一些特殊数值（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。</p><p><code>规约形式的浮点数</code>：如果浮点数中指数部分的编码值在 <code>0 &lt; exponent &lt; 2^(e-1)</code> 之间，且尾数部分最高有效位（即整数字）是 1，那么这个浮点数将被称为规约形式的浮点数。也就是，严格按照我们上文描述编码的数字。</p><p><code>非规约形式的浮点数</code>：如果浮点数的指数部分的编码值是 0，尾数为非零，那么这个浮点数将被称为非规约形式的浮点数。IEEE 754标准规定：<strong>非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值大1</strong>.例如，最小的规约形式的单精度浮点数的指数部分编码值为1，指数的实际值为 -126；而非规约的单精度浮点数的指数域编码值为0，对应的指数实际值也是 -126 而不是 -127。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近 0。规约浮点数的尾数大于等于 1 且小于 2，而非规约浮点数的尾数小于 1 且大于 0。</p><p>上面的两个概念，几乎是直接从wikipedia上扒下来的，<code>非规约形式的浮点数</code>出现的意义是避免<code>突然式下溢出（abrupt underflow）</code>，而采用<code>渐进式下溢出</code>。这已经是上世纪70年代的事情了，差不多是我的年龄的两倍了。这个是一些非常极端的情况，在此我尝试最简单地描述一下<code>非规约形式的浮点数</code>出现的意义，知道有这么回事便可：下面，以单精度为例，如果没有<code>非规约形式的浮点数</code>，那么绝对值最小的两个相邻的浮点数之间的差值将是绝对值最小的浮点数的 <code>2^23</code> 分之一，大家想一下，绝对值次小的浮点数减去绝对值最小的浮点数的值是多少？</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">1.00...01 × 2^(<span class="hljs-string">-126</span>) - 1.00...00 × 2^(<span class="hljs-string">-126</span>) = 0.00..01 × 2^(<span class="hljs-string">-126</span>)<br>                                            = 1 × 2^(<span class="hljs-string">-126</span><span class="hljs-string">-23</span>)<br>                                            = 2^(<span class="hljs-string">-149</span>)<br></code></pre></td></tr></table></figure><p>很明显，绝对值最小的规约数无法表达其和次小的规约数的差值，所以很容易导致有若干数字之间的差值下溢，可能会触发意料之外的后果。而如果采用<code>非规约形式的浮点数</code>，<strong>指数全0，偏移值比规约数偏移值大1（-126比-127大1），尾数小于1</strong>，那么非规约数能表达的最小值便是：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">0.00..01 × 2^(<span class="hljs-string">-126</span>) = 1 × 2^(<span class="hljs-string">-126</span><span class="hljs-string">-23</span>)<br>                    = 2^(<span class="hljs-string">-149</span>)<br></code></pre></td></tr></table></figure><p>所以，<code>非规约形式的浮点数</code>解决了前述的<code>突然式下溢出（abrupt underflow）</code>而被标准采纳。</p><p><code>IEEE 754标准</code>还规定了三个特殊值：</p><ol><li>指数全0且尾数小数部分全 0，则这个数字为 ±0。（符号位决定正负）</li><li>指数为2e – 1且尾数的小数部分全 0，这个数字是 ±∞。（符号位决定正负）</li><li>指数为2e – 1且尾数的小数部分非 0，这个数字是 NaN。</li></ol><p>结合前面的规约数，非规约数以及三个特殊值，可以得到如下总结：</p><p><img src="/img/blog/0102-demo3.png"></p><p>现在，让我们回忆一下，各种语言中普遍描述的双精度浮点数的范围：[-1.7 × 10-308, 1.7 × 10308]。打个岔，想象一个有 300 多位的十进制数字的适用情形，私以为远超过普通人想象力的边界。这个范围为什么是这个范围呢？我觉得，通过上面的讨论，大家应该能清晰，1.7 / 308 这些数字出现的必然原因。</p><p>首先，我们应该很容易根据偏移量得出双精度浮点数的计算公式：</p><p><img src="/img/blog/0102-demo4.png"></p><p>然后，以正数为例，按照上述 <code>特殊值</code> 中 <code>±∞</code> 和 <code>NaN</code> 的约定，指数的最大值应该满足指数取规约数的指数范围的最大值，然后小数部分取小数部分的最大值，可以得出这个二进制的数字应该是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">11111111110</span> <span class="hljs-number">11</span>..<span class="hljs-number">11</span>(<span class="hljs-number">52</span>个)<br></code></pre></td></tr></table></figure><p>转换为16进制表示：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x7fef</span> ffff ffff ffff<br></code></pre></td></tr></table></figure><p>那么，根据前述规约数的原理，反编码便得到十进制的：1.7976931348623157 x 10^308。类似的道理，Sign位取反，便是范围的下限。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>为什么0.1 + 0.2 === 0.30000000000000004 ?</strong></p><p>在浮点数运算中产生误差值的示例中，最出名应该是 0.1 + 0.2 === 0.30000000000000004 了，到底有多有名？看看这个网站就知道了<a href="http://0.30000000000000004.com/">http://0.30000000000000004.com/</a> 也就是说不仅是 JavaScript 会产生这种问题，只要是采用 IEEE 754 Floating-point 的浮点数编码方式来表示浮点数时，则会产生这类问题。下面我们来分析整个运算过程。</p><ol><li><p>0.1 的二进制表示为 1.1001100110011001100110011001100110011001100110011001 1(0011)+ * 2^-4</p></li><li><p>当 64bit 的存储空间无法存储完整的无限循环小数，而 IEEE 754 Floating-point 采用 round to nearest, tie to even的舍入模式，因此 0.1 实际存储时的位模式是 0-01111111011-1001100110011001100110011001100110011001100110011010</p></li><li><p>0.2 的二进制表示为 1.1001100110011001100110011001100110011001100110011001 1(0011)+ * 2^-3</p></li><li><p>当 64bit 的存储空间无法存储完整的无限循环小数，而 IEEE 754 Floating-point 采用 round to nearest, tie to even的舍入模式，因此 0.2 实际存储时的位模式是 0-01111111100-1001100110011001100110011001100110011001100110011010</p></li><li><p>实际存储的位模式作为操作数进行浮点数加法，得到 0-01111111101-0011001100110011001100110011001100110011001100110100。转换为十进制即为 0.30000000000000004。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前后端分离正确理解</title>
    <link href="/2018/07/30/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%AD%A3%E7%A1%AE%E7%90%86%E8%A7%A3/"/>
    <url>/2018/07/30/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%AD%A3%E7%A1%AE%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>在网站开发过程中，对于前后端的分界线似乎一直是众说纷纭。从一开始完全没有前后端的概念，到后来的纠缠不清。那么什么是前后端分离？ 前端后端有两种协作方式，一种可以称之为是服务器端渲染，一种是叫做前后端分离。 这两种方式的差别是什么呢？</p><span id="more"></span><p>服务器端渲染的方式，是指在服务器端就将网页直接生成，浏览器这里拿到的是一整个网页，CSS和JS的部分是在浏览器端执行的，而网页的内容部分，也就是数据，是由服务器端生成的。这叫做服务器端渲染。 至于你是用NodeJS，还是用PHP，还是Python，还是Java，还是NodeJS+Java,都不重要。这是我一直都觉得，很多概念在混淆的原因，很多人都觉得说到前后端分离，就是JS和Java的分离，只要我用了JS，Java提供API，就是前后端分离了。   是这样么？不是的。 只要你的Html网页的内容是在服务器端生成的，这就是服务器端渲染的方式。 只要你的网页是在浏览器端，内容是通过接口从后端拿到的纯数据，这就是前后端分离。   第二种方式就是，前后端分离的方式，也是刚刚说到的。浏览器端先拿到Html，然后和后端通过Ajax接口获取，或者是通过其他接口获取，无所谓。 所以两种方式的区别关键，就在于是，Html是在哪儿生成的，浏览器和服务端传递的是什么。 在前后端分离的方式，浏览器和服务端传递的是数据，而在服务器端渲染的过程中，传递的是Html网页。  </p><p>弄清楚这两点的差别，再来看两种方式的好坏。 1 数据量：前后端分离中传递数据，所以传输量会小。 服务器端渲染，会传输更大的数据，而且，会有很多内容是重复的。 2 体验：前后端多了一个渲染数据的过程，服务器端省去了这个过程。这也是一直被提到的首屏渲染的问题。 3 解耦：前后端分离中，传输的是数据，Model，数据怎么展示，全部交给前端来处理，后端只负责提供数据。 服务器端渲染中，传输的是Html，后端传给前端的Model，通常是通过Hidden的Input来处理，或者是直接用模板技术生成（JSP，Velocity，freemak）等。 数据和展现并未分离，在过去，这被称之为套页面。 4 控制：网页之间有各种跳转交互，在前后端分离中，跳转的页面控制，全部是由前端来决定。跟后端完全没有关系。在服务器端渲染的方式中，大部分是由后端来决定，少部分是由前端来决定。 5 SEO：前后端分离的方式，通常的载体是SPA，所以拿到的是没有数据的空壳子，很多搜索引擎，不支持SPA方式的SEO。 而服务器端渲染的方式，因为生成的是网页，所以对SEO支持的很好。</p><p>不要小巧这个环节，这是重多前台网站放弃使用前后端分离方式的重要原因。 好了，以上5点，足以让你对前后端分离和服务器渲染两种方式有一些直观的认知了。 在什么样的场景下，应该使用前后端分离，很简单。 “不需要SEO的场景下，都应该使用前后端分离”。   所以在后台管理中，没有任何理由不使用前后端分离，代指SPA。 而在前台页面中，要认真考虑，不支持SEO的代价，不止几百万。 前后需要用户登录的页面，往往是不需要有SEO的，这里也可以拆解出来。  </p><p>再说一下，什么是动静分离。 之前跟人讨论的时候，有人说你不懂什么叫前后端分离，就算是服务器端渲染，也可以把CSS和JS从Java代码中剥离出来。 可是这更应该叫做动静分离，跟前后端分离是完全两个含义。 动静分离主要在于部署，静态代码部署不用重启，动态代码部署需要重启，很多时候我改一个样式，不想要重启服务，不想要重新打Tag。   所以，说到前后端分离，前后端只传递数据的方式，是彻底的改变，不是什么后端前端撕逼（所有管理能解决的问题都不是技术问题），也不是什么后端不想要给前后提供数据，就是单纯的这种方式更符合前后端交互的逻辑，后端本来就只应该关心数据，和Android和IOS的交互方式一样，根本不用关心数据怎么展示。 前端说到的前后端分离，在某种程度上，就是和Android和IOS看齐。</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程(OOP编程)</title>
    <link href="/2018/07/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8Boop%E7%BC%96%E7%A8%8B/"/>
    <url>/2018/07/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8Boop%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p><span id="more"></span><p>首先：程序是什么？ 程序 = 算法 + 数据结构 在计算机的世界里，数据就是一个个比特的组合；代码的执行流程就是顺序、分支、循环的程序结构的组合。用计算机解决问题，就是用程序结构的组合去重新排列数据的组合，得到结果。为了从庞大的输入数据（从 bit 的角度上看，任何输入数据都可能非常的庞大），通过代码映射到结果数据。我们就必须用合理的数据结构把这些比特数据组合起来，形成数量更少的单元。 这些单元，就是对象。对象同时也包括了对它进行操作的方法。这样，我们完成了一次封装，就变成了： 程序 = 基于对象操作的算法 + 以对象为最小单位的数据结构 封装总是为了减少操作粒度，数据结构上的封装导致了数据数据的减少，自然减少了问题求解的复杂度；对代码的封装使得代码得以复用，减少了代码的体积，同样使问题简化。 接下来来看 基于对象操作的算法。这种算法必须将操作对象看成是同样的东西。在没有对象的层次上，算法操作的都是字节，是同类。但是到了对象的层次，就不一定相同了。这个时候，算法操作的是一个抽象概念的集合。 在面向对象的程序设计中，我们便少不了容器。容器就用来存放一类有共同抽象概念的东西。这里说有共同概念的东西，而没有说对象。是因为对于算法作用于的集合，里面放的并不是对象实体，而是一个对实体的引用。这个引用表达的是，算法可以对引用的那一头的东西做些什么，而并不要求那一头是什么。 面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义一个Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student。 所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue使用keep-alive注入数据缓存不刷新</title>
    <link href="/2018/07/17/vue%E4%BD%BF%E7%94%A8keep-alive%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E4%B8%8D%E5%88%B7%E6%96%B0/"/>
    <url>/2018/07/17/vue%E4%BD%BF%E7%94%A8keep-alive%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E4%B8%8D%E5%88%B7%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p><keep-alive>是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。 <code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 prop:</p><ul><li>  include: 字符串或正则表达式。只有匹配的组件会被缓存。</li><li>  exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。<span id="more"></span>在2.1.0版本Vue中 常见用法：结合router，缓存部分页面 使用$route.meta的keepAlive属性：</li></ul><keep-alive>    <router-view v-if="$route.meta.keepAlive"></router-view></keep-alive><router-view v-if="!$route.meta.keepAlive"></router-view><p>需要在router中设置router的元信息meta：</p><p>export default new Router({<br>  routes: [<br>    {<br>      path: ‘/‘,<br>      name: ‘MyMusic’,<br>      component: MyMusic,<br>      meta: {<br>        keepAlive: false // 不需要缓存<br>      }<br>    },<br>    {<br>      path: ‘/findmusic’,<br>      name: ‘FindMusic’,<br>      component: FindMusic,<br>      meta: {<br>        keepAlive: true // 需要被缓存<br>      }<br>    }<br>  ]<br>})</p><h3 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a><strong>使用效果</strong></h3><p>初次打开推荐页面会请求数据 <img src="https://www.zhchi.me/wp-content/uploads/2018/07/localhost_8102_iPhone-6_7_8-1-147x300.png"> 回到我的音乐界面 <img src="https://www.zhchi.me/wp-content/uploads/2018/07/localhost_8102_iPhone-6_7_8-2-147x300.png"> 再次回到推荐歌单页面，刚刚请求过的数据会被保存，不会再重新请求 <img src="https://www.zhchi.me/wp-content/uploads/2018/07/localhost_8102_iPhone-6_7_8-1-147x300.png"></p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue-cli 引入axios及跨域使用</title>
    <link href="/2018/07/14/vue-cli-%E5%BC%95%E5%85%A5axios%E5%8F%8A%E8%B7%A8%E5%9F%9F%E4%BD%BF%E7%94%A8/"/>
    <url>/2018/07/14/vue-cli-%E5%BC%95%E5%85%A5axios%E5%8F%8A%E8%B7%A8%E5%9F%9F%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在学习了之前的路由vue-router和状态管理vuex之后，就应该是网络交互了。之前一直用的是vue-resource，但是vue2.0后，尤大大说官方不在推荐vue-resource了，于是开始学习使用axios。 首先是安装 axios</p><p>npm install axios</p><p>安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能每个需要发送请求的组件中即时引入 为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，二是结合 Vuex，封装一个 aciton。这里只说修改原型链的方式。 改写原型链</p><span id="more"></span><p>首先在 main.js 中引入 axios</p><p>import axios from ‘axios’</p><p>这时候如果在其它的组件中，是无法使用 axios 命令的。所以我们将 axios 改写为 Vue 的原型属性</p><p>Vue.prototype.$http= axios</p><p>在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http命令 例如</p><p>methods: {<br>    show() {<br>        this.$http({<br>            method: ‘get’,<br>            url: ‘/user’,<br>            data: {<br>                name: ‘virus’<br>            }<br>         })<br>    }<br>}</p><p>配置 axios 实际上只有 url 是必须的，完整的 api 可以参考<a href="https://www.kancloud.cn/yunye/axios/234845">https://www.kancloud.cn/yunye/axios/234845</a> 对于get请求</p><pre><code>axios.get(&#39;/user&#39;, &#123;      params:&#123;            name:&quot;virus&quot;        &#125;&#125;)</code></pre><p>对于post请求</p><p>  axios.post(‘/user’,{<br>      name:”virus”<br>  })</p><p>一次性并发多个请求</p><p>function getUserAccount(){<br>  return axios.get(‘/user/12345’);<br>}<br>function getUserPermissions(){<br>  return axios.get(‘/user/12345/permissions’);<br>}<br>axios.all([getUserAccount(),getUserPermissions()])<br>  .then(axios.spread(function(acct,perms){<br>    //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果<br>}))</p><p>axios可以通过配置（config）来发送请求</p><p>axios({<br>    method:”POST”,<br>    url:’/user/1111’,<br>    data:{<br>      name:”virus”<br>    }<br>});</p><p>完整的请求还应当包括 .then 和 .catch</p><p>.then(function(res){<br>    console.log(res)<br>})<br>.catch(function(err){<br>    console.log(err)<br>})</p><p>当请求成功时，会执行 .then，否则执行 .catch 这两个回调函数都有各自独立的作用域，如果直接在里面访问 this，无法访问到 Vue 实例,这时只要添加一个 .bind(this) 就能解决这个问题</p><pre><code>.then(function(res)&#123;      console.log(this.data) &#125;.bind(this))</code></pre><p>请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名</p><p>axios.request(config);</p><p>axios.get(url[,config]);</p><p>axios.delete(url[,config]);</p><p>axios.head(url[,config]);</p><p>axios.post(url[,data[,config]]);</p><p>axios.put(url[,data[,config]])</p><p>axios.patch(url[,data[,config]])</p><p>  <strong>跨域问题</strong> config/index.js里配置环境的proxyTable属性</p><p>dev: {<br>    加入以下<br>    proxyTable: {<br>      ‘/zhchi’: {<br>        target: ‘<a href="https://www.zhchi.me/&#39;,//%E8%AE%BE%E7%BD%AE%E4%BD%A0%E8%B0%83%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%9F%9F%E5%90%8D%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7">https://www.zhchi.me/&#39;,//设置你调用的接口域名和端口号</a> 别忘了加http<br>        changeOrigin: true,<br>        pathRewrite: {<br>          ‘^/zhchi’: ‘/‘<br>                //这里理解成用‘/zhchi’代替target里面的地址，<br>                //后面组件中我们掉接口时直接用api代替 比如我要调用’<a href="https://www.zhchi.me/works/vuedata/&#39;%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%86%99%E2%80%98/zhchi/works/vuedata/%E2%80%99%E5%8D%B3%E5%8F%AF">https://www.zhchi.me/works/vuedata/&#39;，直接写‘/zhchi/works/vuedata/’即可</a><br>        }<br>    }<br>}</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Javascript闭包（Closure）</title>
    <link href="/2018/07/12/javascript%E9%97%AD%E5%8C%85%EF%BC%88closure%EF%BC%89/"/>
    <url>/2018/07/12/javascript%E9%97%AD%E5%8C%85%EF%BC%88closure%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a><strong>什么是闭包</strong></h3><p>1.闭包就是能够读取其他函数内部变量的函数。 2.闭包可以用来保存一个需要持久保存的变量。</p><span id="more"></span><p><strong>一、变量的作用域</strong> 要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p><p>var n=999;</p><p>function f1(){<br>　　alert(n);<br>}</p><p>f1(); // 999</p><p>另一方面，在函数外部自然无法读取函数内的局部变量。</p><p>function f1(){<br>　　var n=999;<br>}</p><p>alert(n); // error</p><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p><p>function f1(){<br>　　n=999;<br>}</p><p>f1();</p><p>alert(n); // 999</p><p><strong>二、如何从外部读取局部变量？</strong> 出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。</p><p>function f1(){</p><p>var n=999;</p><p>function f2(){<br>alert(n); // 999<br>}</p><p>}</p><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p><p>function f1(){</p><p>　　var n=999;</p><p>　　function f2(){<br>　　　　alert(n);<br>　　}</p><p>　　return f2;</p><p>}</p><p>var result=f1();</p><p>result(); // 999</p><p><strong>三、闭包的概念</strong> 上一节代码中的f2函数，就是闭包。 各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 <strong>四、闭包的用途</strong> 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 怎么来理解这句话呢？请看下面的代码。</p><p>function f1(){</p><p>　　var n=999;</p><p>　　nAdd=function(){n+=1}</p><p>　　function f2(){<br>　　　　alert(n);<br>　　}</p><p>　　return f2;</p><p>}</p><p>var result=f1();</p><p>result(); // 999</p><p>nAdd();</p><p>result(); // 1000</p><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 <strong>五、使用闭包的注意点</strong> 1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。  </p><h3 id="闭包到底是什么"><a href="#闭包到底是什么" class="headerlink" title="闭包到底是什么"></a><strong>闭包到底是什么</strong></h3><p>闭包是 JS 函数作用域的副产品。 换句话说，正是由于 JS 的函数内部可以使用函数外部的变量，所以这段代码正好符合了闭包的定义。而不是 JS 故意要使用闭包。 很多编程语言也支持闭包，另外有一些语言则不支持闭包。 只要你懂了 JS 的作用域，你自然而然就懂了闭包，即使你不知道那就是闭包！</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h3><h2 id="如果你觉得一个概念很复杂，那么很可能是你理解错了。"><a href="#如果你觉得一个概念很复杂，那么很可能是你理解错了。" class="headerlink" title="如果你觉得一个概念很复杂，那么很可能是你理解错了。"></a><strong>如果你觉得一个概念很复杂，那么很可能是你理解错了。</strong></h2>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript深入之从原型到原型链</title>
    <link href="/2018/07/12/javascript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2018/07/12/javascript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="构造函数与原型"><a href="#构造函数与原型" class="headerlink" title="构造函数与原型"></a><strong>构造函数与原型</strong></h3><p>与大部分面向对象语言不同，JavaScript中并没有引入类（class）的概念，但JavaScript仍然大量地使用了对象，为了保证对象之间的联系，JavaScript引入了原型与原型链的概念。</p><span id="more"></span><p>在Java中，声明一个实例的写法是这样的：</p><p>ClassName obj = new ClassName()</p><p>为了保证JavaScript“看起来像Java”，JavaScript中也加入了new操作符：</p><p>var obj = new FunctionName()</p><p>可以看到，与Java不同的是，JavaScript中的new操作符后面跟的并非类名而是函数名，JavaScript并非通过类而是直接通过构造函数来创建实例。</p><p>function Dog(name, color) {<br>    this.name = name<br>    this.color = color<br>    this.bark = () =&gt; {<br>        console.log(‘wangwang~’)<br>    }<br>}</p><p>const dog1 = new Dog(‘dog1’, ‘black’)<br>const dog2 = new Dog(‘dog2’, ‘white’)</p><p>上述代码就是声明一个构造函数并通过构造函数创建实例的过程，这样看起来似乎有点面向对象的样子了，但实际上这种方法还存在一个很大的问题。 在上面的代码中，有两个实例被创建，它们有自己的名字、颜色，但它们的bark方法是一样的，而通过构造函数创建实例的时候，每创建一个实例，都需要重新创建这个方法，再把它添加到新的实例中。这无疑造成了很大的浪费，既然实例的方法都是一样的，为什么不把这个方法单独放到一个地方，并让所有的实例都可以访问到呢。 这里就需要用到<strong>原型（prototype）</strong>：</p><ul><li>  <strong>每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象。当使用这个构造函数创建实例的时候，prototype属性指向的原型对象就成为实例的原型对象。</strong></li><li>  <strong>原型对象默认拥有一个constructor属性，指向指向它的那个构造函数（也就是说构造函数和原型对象是互相指向的关系）。</strong></li><li>  <strong>每个对象都拥有一个隐藏的属性[[prototype]]，指向它的原型对象，这个属性可以通过 <code>Object.getPrototypeOf(obj)</code> 或 <code>obj.__proto__</code> 来访问。</strong></li><li>  <strong>实际上，构造函数的prototype属性与它创建的实例对象的[[prototype]]属性指向的是同一个对象，即 <code>对象.__proto__ === 函数.prototype</code> 。</strong></li><li>  <strong>如上文所述，原型对象就是用来存放实例中共有的那部分属性。</strong></li><li>  <strong>在JavaScript中，所有的对象都是由它的原型对象继承而来，反之，所有的对象都可以作为原型对象存在。</strong></li><li>  <strong>访问对象的属性时，JavaScript会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中查找。</strong></li></ul><p>那么可以将上述代码稍微做些修改，这里把bark方法放入Dog构造函数的原型中：</p><p>function Dog(name, color) {<br>    this.name = name<br>    this.color = color<br>}</p><p>Dog.prototype.bark = () =&gt; {<br>    console.log(‘wangwang~’)<br>}</p><p>接着再次通过这个构造函数创建实例并调用它的bark方法：</p><p>const dog1 = new Dog(‘dog1’, ‘black’)<br>dog1.bark()  //‘wangwang~’</p><p>可以看到bark方法能够正常被调用。这时再创建另一个实例并重写它的bark方法，然后再次分别调用两个实例的bark方法并观察结果：</p><p>const dog2 = new Dog(‘dog2’, ‘white’)<br>dog2.bark() = () =&gt; {<br>    console.log(‘miaomiaomiao???’)<br>}<br>dog1.bark()  //‘wangwang~’<br>dog2.bark()  //‘miaomiaomiao???’</p><p>这里dog2重写bark方法并没有对dog1造成影响，因为它重写bark方法的操作实际上是为自己添加了一个新的方法使原型中的bark方法被覆盖了，而并非直接修改了原型中的方法。若想要修改原型中的方法，需要通过构造函数的prototype属性：</p><p>Dog.prototype.bark = () =&gt; {<br>    console.log(‘haha<del>‘)<br>}<br>dog1.bark()  //‘haha</del>‘<br>dog2.bark()  //‘haha~’</p><p>这样看起来就没什么问题了，将实例中共有的属性放到原型对象中，让所有实例共享这部分属性。如果想要统一修改所有实例继承的属性，只需要直接修改原型对象中的属性即可。而且每个实例仍然可以重写原型中已经存在的属性来覆盖这个属性，并且不会影响到其他的实例。</p><h3 id="原型链与继承"><a href="#原型链与继承" class="headerlink" title="原型链与继承"></a><strong>原型链与继承</strong></h3><p>上文提到，JavaScript中所有的对象都是由它的原型对象继承而来。而原型对象自身也是一个对象，它也有自己的原型对象，这样层层上溯，就形成了一个类似链表的结构，这就是<strong>原型链（prototype chain）</strong>。 所有原型链的终点都是Object函数的prototype属性，因为在JavaScript中的对象都默认由Object()构造。Objec.prototype指向的原型对象同样拥有原型，不过它的原型是null，而null则没有原型。 通过原型链就可以在JavaScript中实现继承，JavaScript中的继承相当灵活，有多种继承的实现方法，这里只介绍一种最常用的继承方法也就是<strong>组合继承</strong>。</p><p>function Dog(name, color) {<br>    this.name = name<br>    this.color = color<br>}</p><p>Dog.prototype.bark = () =&gt; {<br>    console.log(‘wangwang~’)<br>}</p><p>function Husky(name, color, weight) {<br>    Dog.call(this, name, color)<br>    this.weight = weight<br>}</p><p>Husky.prototype = new Dog()</p><p>这里声明了一个新的构造函数Husky，通过call方法继承Dog中的属性（call方法的作用可以简单理解为将Dog中的属性添加到Husky中，因为还涉及到其他的知识点所以不多赘述），并添加了一个weight属性。然后用Dog函数创建了一个实例作为Husky的原型对象赋值给Husky.prototype以继承方法。这样，通过Husky函数创建的实例就拥有了Dog中的属性和方法。</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flex布局</title>
    <link href="/2018/07/06/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2018/07/06/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>Flexbox 布局（也叫Flex布局，弹性盒子布局）模块目标在于提供一个更有效地布局、对齐方式，并且能够使父元素在子元素的大小未知或动态变化情况下仍然能够分配好子元素之间的间隙。 Flex布局的主要思想是使父元素能够调节子元素的高度、宽度和排布的顺序，从而能够最好地适应可用布局空间（能够适应不同的设备和不同大小的屏幕）。设定为flex布局的父元素（容器）能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。 最重要的是，与传统布局中块状元素按照垂直方向摆放，行内元素按照水平方向摆放相比，flex布局是无方向的。传统布局在应对大型复杂的布局时缺乏灵活性，特别是在改变方向、改变大小、伸展、收缩等等方面。</p><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Flex布局是一个完整的模块而不是一个单独的属性，它包括了完整的一套属性。其中有的属性是设置在容器（container，也可以叫做父元素，称为<code>flex container</code>）上，有的则是设置在容器的项目上（item，也可以叫做子元素，称为<code>flex items</code>）上。 如果我们可以说传统布局是建立在块状元素垂直流和行内元素水平流上的，那么flex布局就是建立在”flex-flow方向”上的，通过下图解释flex布局的主要思想。 <img src="https://www.zhchi.me/wp-content/uploads/2018/07/flexbox-300x128.png"> 在flex布局中，子元素要么按照主轴也就是<code>main axis</code>（从<code>main-start</code>到<code>main-end</code>）排布，要么按照交叉轴，也就是<code>cross axis</code>(从<code>cross-start</code>到<code>cross-end</code>)排布。 下面介绍几个概念：</p><ul><li>  __main axis__: Flex 父元素的主轴是指子元素布局的主要方向轴，注意主轴不一定是水平的，它由属性<code>flex-direction</code>来确定主轴是水平还是垂直的（后面会介绍）。</li><li>  __main-startmain-end__: 分别表示主轴的开始和结束，子元素在父元素中会沿着主轴从<code>main-start</code>到<code>main-end</code>排布。</li><li>  __main size__: 单个项目占据主轴的长度大小。</li><li>  __cross axis__: 交叉轴，与主轴垂直。</li><li>  __cross-startcross-end__: 分别表示交叉轴的开始和结束。子元素在交叉轴的排布从<code>cross-start</code>开始到<code>cross-end</code>。</li><li>__cross size__: 子元素在交叉轴方向上的大小。<h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h2>  属性分作用于父元素的属性和作用于子元素的属性两部分介绍。<h3 id="父元素属性"><a href="#父元素属性" class="headerlink" title="父元素属性"></a>父元素属性</h3><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4>  用来定义父元素是一个 flex布局容器。如果设置为<code>flex</code>则父元素为块状元素，设置为<code>inline-flex</code>父元素呈现为行内元素。  .container {<pre><code>display: flex; /\* or inline-flex \*/</code></pre>  }<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4></li></ul><p><img src="https://www.zhchi.me/wp-content/uploads/2018/07/flex-direction-300x83.png"> <code>flex-direction</code>定义flex布局的主轴方向。flex布局是单方向布局，子元素主要沿着水平行或者垂直列布局。</p><p>.container {<br>  flex-direction: row  row-reverse  column  column-reverse;<br>}</p><ul><li>  <code>row</code>: 行方向，<code>flex-direction</code>的默认值，在<code>ltr</code>(left to right， 从左到右)排版方式下从左到右排列，在<code>rtl</code>(right to left， 从右到左)排版方式下从右到左排列。</li><li>  <code>row-reverse</code>: 行反方向，在<code>ltr</code>中从右向左，在<code>rtl</code>中从左到右。</li><li>  <code>column</code>: 列方向，与<code>row</code>相似，只是从上到下。</li><li>  <code>column-reverse</code>: 列反方向，与<code>row-reverse</code>相似，只是从下岛上。</li></ul><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://www.zhchi.me/wp-content/uploads/2018/07/flex-wrap-300x105.png"></h4><p>默认情况下，flex布局中父元素会把子元素尽可能地排在同一行，通过设置<code>flex-wrap</code>来决定是否允许子元素这行排列。</p><p>.container{<br>  flex-wrap: nowrap  wrap  wrap-reverse;<br>}</p><ul><li>  <code>nowrap</code>: 不折行，默认值，所有的子元素会排在一行。</li><li>  <code>wrap</code>: 折行，子元素会从上到下根据需求折成多行。</li><li>  <code>wrap-reverse</code>: 从下向上折行，子元素会从下岛上根据需求折成多行。</li></ul><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p><code>flex-flow</code>是<code>flex-direction</code>和<code>flex-wrap</code>属性的缩写形式。默认值是<code>row,nowrap</code>。</p><p>flex-flow: &lt;‘flex-direction’&gt;  &lt;‘flex-wrap’&gt;</p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p><img src="https://www.zhchi.me/wp-content/uploads/2018/07/justify-content-263x300.png"> <code>justify-content</code>属性定义了子元素沿主轴方向的对齐方式，用来当子元素大小最大的时候，分配主轴上的剩余空间。也可以当子元素超出主轴的时候用来控制子元素的对齐方式。</p><ul><li>  <code>flex-start</code>: 默认值，朝主轴开始的方向对齐。</li><li>  <code>flex-end</code>: 朝主轴结束的方向对齐。</li><li>  <code>center</code>: 沿主轴方向居中。</li><li>  <code>space-between</code>: 沿主轴两端对齐，第一个子元素在主轴起点，最后一个子元素在主轴终点。</li><li>  <code>space-around</code>: 沿主轴子元素之间均匀分布。要注意的是子元素看起来间隙是不均匀的，第一个子元素和最后一个子元素离父元素的边缘有一个单位的间隙，但两个子元素之间有两个单位的间隙，因为每个子元素的两侧都有一个单位的间隙。</li></ul><p>.container {<br>  justify-content: flex-start  flex-end  center  space-between  space-around;<br>}</p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p><img src="https://www.zhchi.me/wp-content/uploads/2018/07/align-items-248x300.png"> <code>align-items</code>定义了子元素在交叉轴方向的对齐方向，这是在每个子元素仍然在其原来所在行的基础上所说的。可以看作是交叉轴上的<code>justify-content</code>属性;</p><p>.container {<br>  align-items: flex-start  flex-end  center  baseline  stretch;<br>}</p><ul><li>  flex-start: 按照交叉轴的起点对齐。</li><li>  flex-end: 按照交叉轴的终点对齐。</li><li>  center: 沿交叉轴方向居中。</li><li>  baseline: 按照项目的第一行文字的基线对齐。</li><li>stretch: 默认值，在满足子项目所设置的<code>min-height</code>、<code>max-height</code>、<code>height</code>的情况下拉伸子元素使之填充整个父元素。<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://www.zhchi.me/wp-content/uploads/2018/07/align-content-248x300.png"></h4>  <code>align-content</code>是当父元素所包含的行在交叉轴方向有空余部分时如何分配空间。与<code>justify-content</code>在主轴上如何对单个子元素对齐很相似。 <strong>注意</strong>：当只有一行的时候，该属性并不起作用。  .container {<pre><code>align-content: flex-start  flex-end  center  space-between  space-around  stretch;</code></pre>  }  该属性中的六个属性值与<code>justify-content</code>中的六个属性意思相似，不同之处在于<code>justify-content</code>沿主轴方向的作用于单个子元素，而<code>align-content</code>沿交叉轴方向作用于行。遂不再赘述各属性值含义。 注意<code>align-items</code>和<code>align-content</code>的区别，前者是指在单行内的子元素对齐方式，后者是指多行之间的对齐方式。<h4 id="父元素属性总结"><a href="#父元素属性总结" class="headerlink" title="父元素属性总结"></a>父元素属性总结</h4>  <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">display</span>: flexinline-flex;<br>flex-direction: <span class="hljs-built_in">row</span>  <span class="hljs-built_in">row</span>-<span class="hljs-built_in">reverse</span>  column  column-<span class="hljs-built_in">reverse</span>;<br>flex-wrap: nowrap  wrap  wrap-<span class="hljs-built_in">reverse</span>;<br>flex-flow: &lt;‘flex-direction’&gt;  &lt;‘flex-wrap’&gt;;<br>justify-<span class="hljs-built_in">content</span>: flex-start  flex-end  <span class="hljs-built_in">center</span>  <span class="hljs-built_in">space</span>-between  <span class="hljs-built_in">space</span>-around;<br>align-items: flex-start  flex-end  <span class="hljs-built_in">center</span>  baseline  stretch;<br>align-<span class="hljs-built_in">content</span>: flex-start  flex-end  <span class="hljs-built_in">center</span>  <span class="hljs-built_in">space</span>-between  <span class="hljs-built_in">space</span>-around  stretch;<br></code></pre></td></tr></table></figure><h3 id="子元素属性"><a href="#子元素属性" class="headerlink" title="子元素属性"></a>子元素属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4>  <img src="https://www.zhchi.me/wp-content/uploads/2018/07/order-300x191.png">默认情况下，子元素按照代码书写的先后顺序布局，但<code>order</code>属性可以更改子元素出现的顺序。</li></ul><p>.item {<br>  order: <integer>;<br>}</p><p><code>order</code>的默认值为0;子元素的<code>order</code>值越小，布局越排在前面，参考例图理解。</p><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p><img src="https://www.zhchi.me/wp-content/uploads/2018/07/flex-grow-300x65.png"> <code>flex-grow</code>规定在空间允许的情况下，子元素如何按照比例分配可用剩余空间。如果所有的子元素的属性都设定为<code>1</code>，则父元素中的剩余空间会等分给所有子元素。如果其中某个子元素的<code>flex-grow</code>设定为2，则在分配剩余空间时该子元素将获得其他元素二倍的空间（至少会尽力获得）。</p><p>.item {<br>  flex-grow: <number>; /* default 0 */<br>}</p><p><strong>注</strong>：<code>flex-grow</code>不接受负值。默认值为<code>0</code>，意味着即使有剩余空间，各子元素也不会放大。</p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>与<code>flex-grow</code>属性类似，<code>flex-shrink</code>定义了空间不足时项目的缩小比例。</p><p>.item {<br>  flex-shrink: <number>; /* default 1 */<br>}</p><p><strong>注</strong>： <code>flex-shrink</code>不接受负值。<code>flex-shrink</code>默认值为<code>1</code>， 当所有子元素都为默认值时，则空间不足时子元素会同比例缩小。如果其中某个子元素的<code>flex-shrink</code>值为0，则空间不足时该子元素并不会缩小。如果其中某个子元素的<code>flex-shrink</code>值为2时，则空间不足时该子元素会以二倍速度缩小。</p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p><code>flex-basis</code>定义了在计算剩余空间之前子元素默认的大小。可以设置为某个长度（e.g. 20%, 5rem, etc.）或者关键字。关键字<code>auto</code>意味着子元素会按照其本来的大小显示。关键字<code>content</code>意味着根据内容来确定大小——这个关键字到目前没有被很好地支持，所以测试起来比较困难，与<code>content</code>的类似的关键字还有<code>max-content</code>, <code>min-content</code>, <code>fit-content</code>。</p><p>.item {<br>  flex-basis: <length>  auto; /* default auto */<br>}</p><p>如果设置为0, 则子元素内容周围的空隙不会根据<code>flex-grow</code>按比例分配，如果设置为<code>auto</code>，则子元素周围额外的空袭会根据<code>flex-grow</code>按照比例分配，如下图：<img src="https://www.zhchi.me/wp-content/uploads/2018/07/rel-vs-abs-flex-300x151.png"></p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p><code>flex</code>是<code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code>三个属性的缩写。其中第二个和第三个参数(<code>flex-grow</code>,<code>flex-basis</code>)是可选的。默认值为<code>0 1 auto</code>。</p><p>.item {<br>  flex: none  [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;?  &lt;’flex-basis’&gt; ]<br>}</p><p>推荐使用缩写形式而不是单独地设置每一个属性，缩写形式中会智能地计算出相关值。</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p><img src="https://www.zhchi.me/wp-content/uploads/2018/07/align-self-300x153.png"> 通过设置某个子元素的<code>align-self</code>属性，可以覆盖<code>align-items</code>所设置的对齐方式。属性值与<code>align-items</code>中的意义相同，不再赘述。</p><p>.item {<br>  align-self: auto  flex-start  flex-end  center  baseline  stretch;<br>}</p><p><strong>注</strong>：<code>float</code>,<code>clear</code>和<code>vertical-align</code>对flex子元素没有任何影响。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例一：水平垂直居中"><a href="#示例一：水平垂直居中" class="headerlink" title="示例一：水平垂直居中"></a>示例一：水平垂直居中</h3><p>我们从一个非常非常简单的例子开始，解决一个我们经常会遇到的问题：水平垂直居中。如果使用flex布局会非常简单。</p><p>.parent {<br>  display: flex;<br>  height: 300px; /* 随意设定大小 */<br>}</p><p>.child {<br>  width: 100px;  /* 随意设定大小，比父元素要小 */<br>  height: 100px; /* 同上 */<br>  margin: auto;  /* 见证奇迹的时刻 */<br>}</p><p>这个主要原因是，在flex布局的父元素中设置<code>margin</code>为<code>auto</code>会自动吸收额外的空间，所以设置水平垂直的<code>margin</code>都为<code>auto</code>会使子元素在水平垂直方向上都完美居中。</p><h3 id="示例二：响应式初体验"><a href="#示例二：响应式初体验" class="headerlink" title="示例二：响应式初体验"></a>示例二：响应式初体验</h3><p>现在我们考虑用更多的属性。考虑有6个子元素，有固定的大小，但是我们希望他们能够在改变浏览器宽度的时候仍然可以在水平轴上完美地显示（注意在不使用媒体查询的前提下）。</p><p>.flex-container {<br>  /* 首先我们先创建一个flex布局上下文 */<br>  display: flex;</p><p>  /* 然后我们定义flex方向和是否允许子元素换行<br>   * 注意这与以下代码等价：<br>   * flex-direction: row;<br>   * flex-wrap: wrap;<br>   */<br>  flex-flow: row wrap;</p><p>  /* 然后我们定义在剩余空间上子元素如何排布 */<br>  justify-content: space-around;<br>}</p><p>完成。剩下的就是一些其他样式如颜色的设置了。</p><h3 id="示例三：响应式导航栏"><a href="#示例三：响应式导航栏" class="headerlink" title="示例三：响应式导航栏"></a>示例三：响应式导航栏</h3><p>让我们再尝试一些别的东西。假设我们有一个向右对齐的导航栏在我们网页的最上端，但是我们希望它在中屏上显示时为居中，在小屏上显示为单列。同样使用flex布局，实现起来会很简单。</p><p>/* 大屏 */<br>.navigation {<br>  display: flex;<br>  flex-flow: row wrap;<br>  /* 这里设置对齐主轴方向的末端 */<br>  justify-content: flex-end;<br>}</p><p>/* 中屏 */<br>@media all and (max-width: 800px) {<br>  .navigation {<br>    /* 当在中屏上，设置居中，并设置剩余空间环绕在子元素左右 */<br>    justify-content: space-around;<br>  }<br>}</p><p>/* 小屏 */<br>@media all and (max-width: 500px) {<br>  .navigation {<br>    /* 在小屏上，我们不在使用行作为主轴，而以列为主轴 */<br>    flex-direction: column;<br>  }<br>}</p><p><a href="https://www.zhchi.me/works/flex/">查看demo</a> 改变浏览器大小，看看布局会有什么变化吧！</p><h3 id="示例四：移动优先的三栏布局"><a href="#示例四：移动优先的三栏布局" class="headerlink" title="示例四：移动优先的三栏布局"></a>示例四：移动优先的三栏布局</h3><p>我们通过灵活使用flex布局尝试一些更好玩的布局。来做一个移动优先的3列布局并带有全屏宽的header和footer。</p><p>.wrapper {<br>  display: flex;<br>  flex-flow: row wrap;<br>}</p><p>/* 我们要告诉所有的子元素宽度 100% */<br>.header, .main, .nav, .aside, .footer {<br>  flex: 1 100%;<br>}</p><p>/* 移动优先依赖于源代码默认的渲染顺序<br> * in this case:<br> * 1. header<br> * 2. nav<br> * 3. main<br> * 4. aside<br> * 5. footer<br> */</p><p>/* 中屏 */<br>@media all and (min-width: 600px) {<br>  /* 我们要告诉两边的sidebar共享一个行 */<br>  .aside { flex: 1 auto; }<br>}</p><p>/* 大屏幕 */<br>@media all and (min-width: 800px) {<br>  /* 通过order设定各个面板的渲染顺序<br>   * 告诉主要面板元素占用侧栏两倍的空间<br>   */<br>  .main { flex: 2 0px; }</p><p>  .aside-1 { order: 1; }<br>  .main    { order: 2; }<br>  .aside-2 { order: 3; }<br>  .footer  { order: 4; }<br>}</p><p><a href="https://www.zhchi.me/works/flex/index2.html">查看demo</a> 改变浏览器大小，看看布局会有什么变化吧！</p><h2 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h2><p>Flex布局需要一些浏览器前缀来最大力度地兼容大多数的浏览器。Flex布局的前缀不只是在属性前面添加浏览器前缀，不同浏览器下的属性名和属性值都不同，这是因为Flexbox布局的标准一直在变，一共有old, tweener, new 三个版本。 可能处理前缀的最好方法是使用新的语法书写CSS并通过<a href="https://css-tricks.com/autoprefixer/">Autoprefixer</a>运行CSS，能够很好地处理这个问题。 另外，这里有一个Sass中 @mixin 来处理一些前缀，也可以给你一些处理前缀的启发：</p><p>@mixin flexbox() {<br>  display: -webkit-box;<br>  display: -moz-box;<br>  display: -ms-flexbox;<br>  display: -webkit-flex;<br>  display: flex;<br>}</p><p>@mixin flex($values) {<br>  -webkit-box-flex: $values;<br>  -moz-box-flex:  $values;<br>  -webkit-flex:  $values;<br>  -ms-flex:  $values;<br>  flex:  $values;<br>}</p><p>@mixin order($val) {<br>  -webkit-box-ordinal-group: $val;<br>  -moz-box-ordinal-group: $val;<br>  -ms-flex-order: $val;<br>  -webkit-order: $val;<br>  order: $val;<br>}</p><p>.wrapper {<br>  @include flexbox();<br>}</p><p>.item {<br>  @include flex(1 200px);<br>  @include order(2);<br>}</p><p> </p><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>首先看一下Flex布局的三个版本</p><ul><li>  (new)是指标准中最近的语法(e.g. <code>display:flex;</code>)。</li><li>  (tweener)是指2011年以后非官方的临时版本(e.g. <code>display:flexbox;</code>)。</li><li>  (old)是指2009年以后的旧语法(e.g. <code>display:box;</code>)</li></ul><p><img src="https://www.zhchi.me/wp-content/uploads/2018/07/browser-support-300x66.png"> Blackberry browser 10+ 支持新语法。 更多混合使用语法达到最佳浏览器兼容，可以参考<a href="https://css-tricks.com/using-flexbox/">this article (CSS-Tricks)</a>或者<a href="http://dev.opera.com/articles/view/advanced-cross-browser-flexbox/#fallbacks">this article (DevOpera)</a></p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue静态资源打包中的坑与解决方案</title>
    <link href="/2018/07/02/vue%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85%E4%B8%AD%E7%9A%84%E5%9D%91%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2018/07/02/vue%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85%E4%B8%AD%E7%9A%84%E5%9D%91%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>本文主要解决 ①.vue-cli默认配置打包后部署至特定路径下静态资源路径错误问题; ②.静态资源打包使用相对路径后css文件引入大图片路径错误问题。</p><span id="more"></span><p>1.问题</p><blockquote><p>vue-cli 脚手架生成的默认打包配置文件情况下运行 npm run build 打包后，部署项目至特定路径下：如：</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//i</span>p:port<span class="hljs-regexp">/public/</span>springActivity/<br></code></pre></td></tr></table></figure><p>此时访问：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//i</span>p:port<span class="hljs-regexp">/public/</span>springActivity/index.html<br></code></pre></td></tr></table></figure><p>index.html 可以正常访问，但是引用的js，css等文件服务器响应均为404，查看引入的资源路径如下：</p><p><a href="http://ip:port/static/css/app.cea07642cd24c0d7a5c4b9b7afc7ff64.css">http://ip:port/static/css/app.cea07642cd24c0d7a5c4b9b7afc7ff64.css</a><br><a href="http://ip:port/static/js/app.815851e87b083afb82bf.js">http://ip:port/static/js/app.815851e87b083afb82bf.js</a></p><p>  2.分析</p><blockquote><p>由上可以看出是资源打包路径有误，打包后的资源使用了绝对根目录路径，因此将项目部署到特定目录下，其引入的资源路径无法被正确解析。 3.解决</p></blockquote><blockquote><p>在打包时需要使用相对路径来处理静态资源，更改build中资源发布路径配置（config/index.js, build对象）：</p></blockquote><p>将 assetsPublicPath: ‘/‘ 改为 assetsPublicPath: ‘./‘,</p><p>再次打包，并将资源部署到特定路径下，然后访问： 此时index.html可以正常访问，同时js和css资源也可以正常访问，但是css中引入的assets目录下的大图片资源出错了（服务端404）.</p><p>  4.再分析</p><blockquote><p>查看引入的图片资源路径如下：</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//i</span>p:port<span class="hljs-regexp">/public/</span>springActivity<span class="hljs-regexp">/static/</span>css<span class="hljs-regexp">/static/img</span><span class="hljs-regexp">/question_bg.61a2825.png</span><br></code></pre></td></tr></table></figure><blockquote><p>实际项目中资源路径如下：</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">index</span>.html<br>static/<br>    <span class="hljs-comment">--js/</span><br>        <span class="hljs-comment">--*.js</span><br>    <span class="hljs-comment">--css/</span><br>        <span class="hljs-comment">--*.css</span><br>    <span class="hljs-comment">--img/</span><br>        <span class="hljs-comment">--*.png</span><br></code></pre></td></tr></table></figure><blockquote><p>很明显图片引入路径有误。分析图片引入路径，发现路径均多了”/static/css”两层目录，猜测是css目录下的css文件引入图片路径为”static/img/question_bg.61a2825.png” , 查看css文件，css中引入图片路径如下：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">static/img/question_bg.61a2825.png</span>)<br></code></pre></td></tr></table></figure><p>  5.再解决</p><blockquote><p>css文件中路径存在问题，肯定又是打包哪个环节资源路径没有配置好，分析打包过程，css是在js中引入的或是写在vue文件中的，css文件首先被less，postcss等处理，处理后会被ExtractTextPlugin处理，ExtractTextPlugin将js中的css全部抽离至app.css文件中。</p></blockquote><blockquote><p>首先将options.extract设为false，关闭抽离css功能，再次打包并部署至特定目录，访问：<a href="http://ip:port/public/springActivity/index.html">http://ip:port/public/springActivity/index.html</a>, 啪，页面正常显示，大公即将告成。</p></blockquote><blockquote><p>分析打包后的文件，发现没有了css文件，发现css文件全部在app.js文件中；通过js将css注入 index.html文件中，因此css文件中引入的图片资源路径应该是相对于index.html文件路径的，即:”static/img/question_bg.61a2825.png”,这与下面css文件中的图片资源路径一致，因此图片能够被正常访问。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">static/img/question_bg.61a2825.png</span>)<br></code></pre></td></tr></table></figure><blockquote><p>现在很确定知道问题出在哪了，即：ExtractTextPlugin抽离css文件时没有转换资源引入路径，导致app.css引入了相对app.css目录为”static/img/<em>.png”的静态资源，该路径相对index.html即为：static/css/static/img/</em>.png。</p></blockquote><blockquote><p>因此使用ExtractTextPlugin插件时还需要配置静态资源路径参数，通过查询资料，得知可以通过添加publicPath:”../../“解决该问题：</p><p>if (options.extract) {<br>  return ExtractTextPlugin.extract({<br>    use: loaders,<br>    fallback: ‘vue-style-loader’,<br>    publicPath:”../../“                 //添加<br>  })<br>}</p><p>打包部署到特定目录下后访问index.html文件，页面一切正常，app.css文件正常引入，图片资源也正常引入，查看app.css文件引入图片资源方式如下：</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">background:url(..<span class="hljs-regexp">/../</span><span class="hljs-keyword">static</span><span class="hljs-regexp">/img/</span>question_bg.<span class="hljs-number">61</span>a2825.png<br></code></pre></td></tr></table></figure><p>publicPath配置后，css文件中引入的图片文件路径前添加了该路径配置；</p><hr><blockquote><p>publicPath 属性值为打包后的 app.css文件至index.html文件的相对路径</p></blockquote><blockquote><p>图片资源也可以直接放在vue-cli生成的static目录下规避上述问题，但是通过这种方式图片名称中无法增加md5字符串，不利于版本控制</p></blockquote><p>转自掘金：链接：<a href="https://juejin.im/post/5a75c8ce5188257a624c9ff1">https://juejin.im/post/5a75c8ce5188257a624c9ff1</a></p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>尾调用优化</title>
    <link href="/2018/05/09/%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96/"/>
    <url>/2018/05/09/%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>我们普通递归的问题在于展开的时候会产生非常大的中间缓存，而每一层的中间缓存都会占用我们宝贵的栈上空间，所有导致了当这个 n 很大的时候，栈上空间不足则会产生“爆栈”的情况。 那有没有一种方法能够避免这样的情况呢？那当然是有的，那就是我们这篇文章的主角——尾递归了。</p><span id="more"></span><p>首先，我们来说一下尾调用。尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><p>function f(x){<br>    return g(x);<br>}</p><p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下两种情况，都不属于尾调用。</p><p>// 情况一<br>function f(x){<br>    let y = g(x);<br>    return y;<br>}</p><p>// 情况二<br>function f(x){<br>    return g(x) + 1;<br>}</p><p>上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。 尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p><p>function f(x) {<br>    if (x &gt; 0) {<br>        return m(x)<br>    }<br>    return n(x);<br>}</p><p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个<a href="http://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88">“调用栈”</a>（call stack）。 <img src="https://www.zhchi.me/wp-content/uploads/2018/05/bg2015041002-300x93.png"> 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p><p>function f() {<br>    let m = 1;<br>    let n = 2;<br>    return g(m + n);<br>}<br>f();</p><p>// 等同于<br>function f() {<br>    return g(3);<br>}<br>f();</p><p>// 等同于<br>g(3);</p><p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。 这就叫做”尾调用优化”（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是”尾调用优化”的意义。 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p><p>function factorial(n) {<br>    if (n === 1) return 1;<br>    return n * factorial(n - 1);<br>}</p><p>factorial(5) // 120</p><p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p><p>function factorial(n, total) {<br>    if (n === 1) return total;<br>    return factorial(n - 1, n * total);<br>}</p><p>factorial(5, 1) // 120</p><p><img src="https://www.zhchi.me/wp-content/uploads/2018/05/bg2015041003-300x276.png"> 由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p><p>function tailFactorial(n, total) {<br>    if (n === 1) return total;<br>    return tailFactorial(n - 1, n * total);<br>}</p><p>function factorial(n) {<br>    return tailFactorial(n, 1);<br>}</p><p>factorial(5) // 120</p><p>上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。 函数式编程有一个概念，叫做<a href="https://en.wikipedia.org/wiki/Currying">柯里化</a>（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p><p>function currying(fn, n) {<br>    return function (m) {<br>        return fn.call(this, m, n);<br>    };<br>}</p><p>function tailFactorial(n, total) {<br>    if (n === 1) return total;<br>    return tailFactorial(n - 1, n * total);<br>}</p><p>const factorial = currying(tailFactorial, 1);</p><p>factorial(5) // 120</p><p>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。 第二种方法就简单多了，就是采用ES6的函数默认值。</p><p>function factorial(n, total = 1) {<br>    if (n === 1) return total;<br>    return factorial(n - 1, n * total);<br>}</p><p>factorial(5) // 120</p><p>上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持”尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。   ES6的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li>  <code>arguments</code>：返回调用时函数的参数。</li><li>  <code>func.caller</code>：返回调用当前函数的那个函数。</li></ul><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 本文转自：<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">阮一峰的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归、循环和迭代</title>
    <link href="/2018/05/09/%E9%80%92%E5%BD%92%E3%80%81%E5%BE%AA%E7%8E%AF%E5%92%8C%E8%BF%AD%E4%BB%A3/"/>
    <url>/2018/05/09/%E9%80%92%E5%BD%92%E3%80%81%E5%BE%AA%E7%8E%AF%E5%92%8C%E8%BF%AD%E4%BB%A3/</url>
    
    <content type="html"><![CDATA[<p>今天在项目中遇到了无限循环和递归，我不经思考一个问题。所有的递归都能用循环实现吗？递归和循环有本质上的区别吗？？</p><p>function log () {<br>    …<br>}</p><p>function loop () {<br>    log();<br>    loop();<br>}</p><p>for ( ; ; ) {<br>    log();<br>}</p><p>上面这段代码看上去好象所有递归都可以用循环的方式实现，那么他们本质上是一样的吗？</p><span id="more"></span><p>首先看一下这几个概念的概念：</p><ul><li>  循环（loop），指的是在满足条件的情况下，重复执行同一段代码。比如，while语句。</li><li>  迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项。比如，for语句。</li><li>  遍历（traversal），指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。</li><li>  递归（recursion），指的是一个函数不断调用自身的行为。比如，以编程方式输出著名的斐波纳契数列。</li></ul><p>有了以上定义，这几个概念之间的区别其实就比较清楚了。至于它们之间的联系，严格来讲，它们似乎都属于算法的范畴。换句话说，它们只不过是解决问题的不同手段和方式，而本质上则都是计算机编程中达成特定目标的途径。 循环和递归最主要的区别就是效率上的区别，大家都知道递归比循环慢，那这是为什么呢？ 大家都知道递归的实现是通过调用函数本身，函数调用的时候，每次调用时要做地址保存，参数传递等，这是通过一个递归工作栈实现的。具体是每次调用函数本身要保存的内容包括：局部变量、形参、调用函数地址、返回值。那么，如果递归调用N次，就要分配N*局部变量、N*形参、N*调用函数地址、N*返回值。这势必是影响效率的。 递归与循环是两种不同的解决问题的典型思路。当然也并不是说循环效率就一定比递归高，递归和循环是两码事，递归带有栈操作，循环则不一定，两个概念不是一个层次，不同场景做不同的尝试。 递归其实是方便了程序员难为了机器。它只要得到数学公式就能很方便的写出程序。优点就是易理解，容易编程。但递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，对嵌套层数深的一些算法，递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许多额外的时间开销。所以在深度大时，它的时空性就不好了。 循环其缺点就是不容易理解，编写复杂问题时困难。优点是效率高。运行时间只因循环次数增加而增加，没什么额外开销。空间上没有什么增加。局部变量占用的内存是一次性的，也就是O(1)的空间复杂度，而对于递归（不考虑尾递归优化的情况），每次函数调用都要压栈，那么空间复杂度是O(n)，和递归次数呈线性关系。 递归程序改用循环实现的话，一般都是要自己维护一个栈的，以便状态的回溯。如果某个递归程序改用循环的时候根本就不需要维护栈，那其实这个递归程序这样写只是意义明显一些，不一定要写成递归形式。但很多递归程序就是为了利用函数自身在系统栈上的auto变量记录状态，以便回溯。</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>H5实现alpha通道视频</title>
    <link href="/2018/04/24/h5%E5%AE%9E%E7%8E%B0alpha%E9%80%9A%E9%81%93%E8%A7%86%E9%A2%91/"/>
    <url>/2018/04/24/h5%E5%AE%9E%E7%8E%B0alpha%E9%80%9A%E9%81%93%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<p>目前在做一个项目，项目要求扫描AR播放一段alpha通道视频，我查了一些资料，发现h5如何运用透明通道的视频的资料介绍很少。一般透明视频是mov格式的，但是h5只支持MP4、webm和ogg，并不支持mov。 首先，我们先了解一下alpha通道是什么：alpha通道是一个8位的灰度通道，该通道用256级灰度来记录图像中的透明度信息，定义透明、不透明和半透明区域，其中白表示不透明，黑表示透明，灰表示半透明。RGBA中的A指的就是alpha，alpha通道一般用作不透明度参数。如果一个像素的alpha通道数值为0%，那它就是完全透明的（也就是看不见的），而数值为100%则意味着一个完全不透明的像素（传统的数字图像）。在0%和100%之间的值则使得像素可以透过背景显示出来。</p><span id="more"></span><p>在我查资料的时候发现webm是可以带alpha通道的，可是悲催的是只有chrome支持webm的alpha通道，别的浏览器暂时还不支持，sad；只好想别的方法了。   <strong>第一种方法PNG序列帧</strong> 我们常见的带alpha通道的文件是png图片，所以我首先想到的也是最简单的方法是通过png序列帧实现alpha透明通道视频，代码如下：</p><p>$(function(){<br>    var i = 0;<br>    var timer = setInterval(function(){<br>        i++;<br>        i = parseInt(i);<br>        if (i &lt; 10){<br>            $(“#img img”).attr(“src”,”./img/Comp 1_0000”+i+”.png”);<br>        } else if(i &lt; 100){<br>            $(“#img img”).attr(“src”,”./img/Comp 1_000”+i+”.png”);<br>        } else if(i &lt; 234){<br>            $(“#img img”).attr(“src”,”./img/Comp 1_00”+i+”.png”);<br>        } else if(i == 234){<br>            $(“#img img”).attr(“src”,”./img/Comp 1_00234.png”);<br>            clearInterval(timer)<br>        }<br>    }, 1000 / 24);<br>})</p><p>但是经过测试发现序列帧方法实现通道视频有个缺点，就是图片太大了；体验不是很好。   <strong>第二种方法借助canvas重新绘制视频内容。</strong> 将视频画面取出来将不要的部分抠除，要留下的部分放到canvas里重新绘制成视频，首先需要用视频剪辑软件将视频做成这样： <img src="https://www.zhchi.me/wp-content/uploads/2018/04/CG4J1S@DNY0MRAA_K-93x300.png"> 上下两部分，当然左右也是可以的，随便你怎么高兴怎么来，一边是原本的视频，一边是黑白的，白色表示你要留下的部分，黑色表示你要抠除的部分。 下面是代码：</p><p>var showCanvas = document.getElementById(“show”);<br>var showCtx = showCanvas.getContext(“2d”);<br>var bufferCanvas = document.getElementById(“buffer”);<br>var bufferCtx = bufferCanvas.getContext(“2d”);<br>var video = document.getElementById(‘alpha-video’);<br>var width = showCanvas.width;<br>var height = showCanvas.height;<br>var image;<br>var alphaData;</p><p>video.play();</p><p>function processFrame () {<br>bufferCtx.drawImage(video, 0, 0, width, height * 2);<br>image = bufferCtx.getImageData(0, 0, width, height),<br>alphaData = bufferCtx.getImageData(0, height, width, height).data;</p><p>for (var i = 3, len = image.data.length; i &lt; len; i = i + 4) {<br>image.data[i] = alphaData[i - 1];<br>}<br>showCtx.putImageData(image, 0, 0, 0, 0, width, height);<br>requestAnimationFrame(processFrame);<br>}</p><p>video.addEventListener(‘play’, function() {<br>$(‘#loading’).hide();<br>processFrame();<br>}, false);</p><p>video.addEventListener(‘ended’, function() {<br>console.log(‘播放完毕跳转’);<br>}, false);</p><p>经过测试这种方法在pc上面显示效果比较好，较新的手机上也没有问题，但是在低端手机上会有卡顿。 完整demo  github链接：<a href="https://github.com/zhchi-me/alpha-video-html5">https://github.com/zhchi-me/alpha-video-html5</a></p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈前端页面的优化与提速</title>
    <link href="/2018/04/17/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%8E%E6%8F%90%E9%80%9F/"/>
    <url>/2018/04/17/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%8E%E6%8F%90%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<p>当今的世界是互联网的世界，IT企业之间的竞争是很激烈的，如果一个网页的加载和显示速度，相比别人的站点页面有那么0.1秒的提升，那也是很大的一个成就。 研究表明：用户最满意的打开网页时间是2-5秒，如果等待超过10秒，99%的用户会关闭这个网页。也许这样讲，各位还不会有太多感触，接下来我列举一组数据：Google网站访问速度每慢400ms就导致用户搜索请 求下降0.59%;Amazon每增加100ms网站延迟将导致收入下降1%;雅虎如果有400ms延迟会导致流量下降5-9%。网站的加载速度严重影响了用户体验，也决定了这个网站的生死存亡。我们来聊聊前端攻城狮如何来提高页面的加载速度。</p><span id="more"></span><p>Web应用通常以网络作为访问前提，而访问者的网络带宽是有限的，所以在单位时间有限的带宽下，访问的资源大小越小则访问的速度必然更快。同时，每请求一个资源都会增加一次HTTP请求，而每个请求也势必会消耗一定的服务器响应时间，因此我们可以从此方向着手进行相关优化。  </p><h4 id="一-缩减资源-HTML、CSS和JavaScript-的大小"><a href="#一-缩减资源-HTML、CSS和JavaScript-的大小" class="headerlink" title="一.缩减资源(HTML、CSS和JavaScript)的大小"></a>一.缩减资源(HTML、CSS和JavaScript)的大小</h4><p>缩减资源大小是指删除不必要的字节（例如，不必要的空格、换行符、缩进和注释）。压缩HTML、CSS和JavaScript可提高下载、解析和执行的速度，提升加载速度。可以通过以下方式进一步缩小文件体积：</p><ul><li>  要缩减HTML的大小，可使用HTML Minifier等类似的工具对HTML文件进行压缩，如果你使用自动化工具，如Gulp，可以使用gulp-htmlmin等插件进行压缩。</li><li>  要缩减CSS的大小，可使用YUI Compressor和cssmin.js等工具，或使用Gulp的gulp-csso等插件进行压缩。</li><li>  要缩减JavaScript的大小，可使用Google Closure Compiler和UglifyJS等工具，同样可以使用Gulp的gulp-uglify等插件进行压缩。</li><li>  最后可以使用Gulp的gulp-concat或gulp-useref等合并插件对CSS和JavaScript进行文件合并处理。</li></ul><p> </p><h4 id="二-优化图片"><a href="#二-优化图片" class="headerlink" title="二.优化图片"></a>二.优化图片</h4><p>尽量减小图片尺寸，以缩减用户等待资源加载的时间。适当地设置图片的格式并进行压缩可以节省大量的数据字节空间。这样可以为那些网络连接较慢的用户节约时间，还可以为有流量套餐限制的用户节省成本。  </p><h4 id="三-减少对服务器的文件请求"><a href="#三-减少对服务器的文件请求" class="headerlink" title="三.减少对服务器的文件请求"></a>三.减少对服务器的文件请求</h4><p>常规的HTTP请求属于“请求”-“应答”-“断开”形式的短连接，每一个独立的资源我们都会向服务器发去一份get请求，再等服务端将我们需要的文件传回来。每一次资源的请求都实实在在地耗费了一次“连接-等待-接收”的时间（当然将http请求设为keep-alive长连接状态可以减少“连接”的次数和时间），如果我们能有效减少对服务器文件的请求次数，便意味着我们可以从这块省下一些页面等待时间，也可以顺便减少服务器的负担。 对于这个解决方案，我们可以这么做： 1. 使用css sprite技术合并多个图片为单个图片文件，实际使用时通过background-position来定位背景位置（相信大家第一个想到的也是这个吧）； 2. 合并多个css样式文件为单个样式文件，合并多个脚本为单个脚本，再在页面中引用合并后的样式/脚本文件。但我个人倒是不怎么推荐这个方法，因为合并了文件之后，多个页面之间公共部分的样式/脚本文件就无法缓存到客户端了； 3. 使用base64编码来展示图片。 4. 将小块的css、js代码段直接写在页面上，而非在页面引入独立的样式/脚本文件。相信有的朋友看惯了“保持结构 （标记）、表现 （样式）、行为 （脚本）三者分离”的规范，对此观点可能有些意见。只能说规范不是教条，适合自己的才是硬道理。直接把小段的、复用率低的样式/脚本直接写于页面上带来的利还是大于弊的（弊可能也就是增大了页面代码量、不那么好维护了点）。反观所有主流门户网站的页面源文件，基本没有一个是把样式/脚本都全部作为外部文件引入的（无论他们是否从减少服务器请求这点出发，事实都是这样），配合gzip压缩会是很好的选择。 5. 利用http-equiv=”expires”元标签，设定一个未来的某时间点作为页面文件过期时间，用户在过期时间之前所获取到的页面文件都仅从缓存中去取。最好的形式是给资源名称加md5之类的唯一标识符后缀，然后设置一段较长的过期时间，同时请后端配置好ETag。  </p><h4 id="四-适度使用CDN"><a href="#四-适度使用CDN" class="headerlink" title="四.适度使用CDN"></a>四.适度使用CDN</h4><p>使用CDN有几个好处：如果用户在其它站点下载过这个CDN资源，那么来我们站点仅仅从缓存获取即可；减少了对自己站点服务器的文件请求（外部CDN的情况下），减少服务器负担；多个域会使浏览器允许异步下载资源的最大数量增多，比如一个站点只从一个域来请求资源，那么FireFox只允许同时刻最多异步下载2个文件，但如果使用了外部CDN来引入资源，那么FF允许在同时异步下载本域中的两个资源外，还额外允许同时异步下载另一个域（CDN）下的2个资源。 但是使用CDN有一个很大的问题——增加了dns解析的开销，如果一个页面同时引入了多个CDN的资源，可能会因为dns解析而陷入较多的等待时间，导致得不偿失。 对于这个问题，常规是建议一个站点下只使用同一个可靠、快速的CDN来引入各种所需资源即可，也就是说，建议一个页面从2个不同的域（比如站点域和CDN域）下来请求资源是最佳的选择。  </p><h4 id="五-减少DNS查找"><a href="#五-减少DNS查找" class="headerlink" title="五.减少DNS查找"></a>五.减少DNS查找</h4><p>当我们在浏览器的地址栏输入网址（譬如： <a href="http://www.zhchi.me)/">www.zhchi.me）</a> ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？ 域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户 域名解析是页面加载的第一步，那么域名是如何解析的呢？以Chrome为例：</p><blockquote><p>1.  Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="http://www.linux178.com/">www.linux178.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。<br> 注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看</p><ol start="2"><li><p>如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.<br>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看 </p></li><li><p> 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p></li><li><p> 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问<a href="http://www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com对应的IP地址，该进行一步的动作了。">www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com对应的IP地址，该进行一步的动作了。</a></p></li></ol><p>注：一般情况下是不会进行以下步骤的</p><p>如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤：<br>5.  操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</p><ol start="6"><li><p> 如果第5步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）</p></li><li><p> 如果第6步也没有查询成功，那么客户端就要进行广播查找</p></li><li><p> 如果第7步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）</p></li></ol><p>如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p></blockquote><p>DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？ 当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的 数量就可以减少DNS查找的数量。 减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP 1.1规范建议从每个主机名并行下载两个组件，但实际上可以多个），这样减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于4个主机名下，减少DNS查找的同时也允许高度并行下载。  </p><h4 id="六-延迟请求、异步加载脚本"><a href="#六-延迟请求、异步加载脚本" class="headerlink" title="六.延迟请求、异步加载脚本"></a>六.延迟请求、异步加载脚本</h4><p>在各主流浏览器下，常规情况，我们的脚本文件跟随其它资源文件一样都是异步下载的，但这里存在一个问题——比如FireFox下载好脚本后的一小段时间内会有“执行阻塞”的情况发生，也就是说浏览器下载好脚本后执行它的这段时间里，浏览器的其它行为被阻塞，导致页面上的其它资源都是无法被请求和下载的。 如果你页面里存在js代码执行时间过长的情况，那么用户就会明显感觉到页面的延迟。解决这个问题有一个简单的方法——将脚本请求标签放置到</body>结束标签前，使得页面上的脚本成为最后被请求的资源，自然也不会阻塞其它页面资源的请求事件了。 另外，虽然上面提到“我们的脚本文件跟随其它资源文件一样都是异步下载的”，但异步下载不代表异步执行，为了严格保证脚本逻辑顺序和依赖关系的正确性，浏览器会按照脚本被请求的先后顺序来执行脚本。那么问题就来了——如果页面上的脚本依赖关系并不大，甚至没有任何相互间的依赖，那么浏览器的这套规则就仅仅增加了页面请求阻塞时间而已）。 解决这个问题的办法无非就是让脚本无阻塞地异步执行，比如给script标签加上defer和async属性或者动态注入脚本，但这些都不是良好的解决方案，要么存在兼容性问题，要么太麻烦还无法处理依赖。 个人是推荐使用 requireJS（AMD规范） 或 seaJS（CMD规范） 来异步加载脚本并处理模块依赖的，前者将“依赖前置”（预加载所有被依赖脚本模块，执行速度最快），后者走的“依赖就近”（懒加载被依赖脚本模块，请求脚本更科学），你可以根据项目具体需求来选择最合适的。  </p><h4 id="七-首屏加载优化"><a href="#七-首屏加载优化" class="headerlink" title="七.首屏加载优化"></a>七.首屏加载优化</h4><p>先解释下，“首屏”指的是页面初始化时候的页面内容显示区域，也就是页面一加载，用户就首先看到的区域。 如果所需的数据量超出初始拥塞窗口(Congestion Window)的限制，系统就需要在服务器和用户浏览器之间进行更多次的往返。如果用户使用的是延迟时间较长的网络（例如，移动网络），该问题会严重延迟网页的加载。 我们可以这样实现此方案，不依赖任何lazyload库，拿图片来做示范，我们可以这样编写首屏外的图片（假设某张图片地址是a.jpg）的img标签：</p><img src="data:image/png;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" data-src="a.jpg"><p>如上所示，页面初步加载这张图片的时候是直接以base64的方式（当然你也可以统一使用一张占位图loading.gif来替代）来快速显示一张极小的图片的，而图片本身的真实路径是存在data-src属性内的，我们可以在页面加载结束后再向服务器请求它真实的文件并替换：</p><p>function init() {<br>    var imgDefer = document.getElementsByTagName(‘img’);<br>    for (var i=0; i&lt;imgDefer.length; i++) {<br>        if(imgDefer[i].getAttribute(‘data-src’)) {<br>             imgDefer[i].setAttribute(‘src’,imgDefer[i].getAttribute(‘data-src’));<br>        }<br>    }<br>}<br>window.onload = init;</p><p>如上是对图片的延迟加载处理，对于视频、音频文件，可以采取完全一样的原理来延迟加载，从而有效减少页面初始化等待时间。 <strong>结构化HTML，以便首先加载关键的首屏内容</strong> 应考虑首先加载网页的主要内容。结构化网页，以便服务器发出的初始响应能发送必要数据，从而迅速呈现网页的关键部分并暂缓呈现其余部分。如果可能，你应该将CSS拆分为两个部分：页面的主要内容（例如，文章、产品和描述内容），以及可暂缓呈现的部分（例如，评论、广告和第三方小部件）。可以参考以下示例，了解有关如何结构化网站以提高加载速度：</p><ul><li>  如果你的网站采用的是两列布局（如文章加侧边栏），而HTML先加载边栏，再加载文章，应考虑首先加载文章。</li></ul><p> </p><h4 id="八-将样式表放在头部"><a href="#八-将样式表放在头部" class="headerlink" title="八.将样式表放在头部"></a>八.将样式表放在头部</h4><p>首先说明一下，将样式表放在头部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，防止“白屏”。 我们总是希望页面能够尽快显示内容，为用户提供可视化的回馈，这对网速慢的用户来说是很重要的。 将样式表放在文档底部会阻止浏览器中的内容逐步出现。为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为：如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前务虚会之任何东西  </p><h4 id="九-将脚本放在底部"><a href="#九-将脚本放在底部" class="headerlink" title="九.将脚本放在底部"></a>九.将脚本放在底部</h4><p>跟样式表相同，脚本放在底部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现。 js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。 下载脚本时并行下载是被禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内容，因此浏览器会等待；另外，也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存在依赖关系，不按照顺序执行可能会产生错误。  </p><h4 id="十-避免CSS表达式"><a href="#十-避免CSS表达式" class="headerlink" title="十.避免CSS表达式"></a>十.避免CSS表达式</h4><p>如果要动态设置CSS属性，CSS表达式（CSS expressions）就显得尤其强（wei）大（xian），它在IE5.0中开始被支持，但又在IE8.0中被废弃。 减少CSS表达式执行次数的方法是：当页面渲染完成后就给CSS属性设定一个明确的值，或者在Js中监听网页事件，事件触发时再去设置CSS属性值。如果一定要使用CSS表达式，请记住，它很可能会被执行成千上万次。  </p><h4 id="十一-减少DOM操作"><a href="#十一-减少DOM操作" class="headerlink" title="十一.减少DOM操作"></a>十一.减少DOM操作</h4><p>如果一个页面太复杂，意味着下载时间更长，同时JS访问DOM的速度也会变慢。减少DOM数并不意味着需要移除内容，而是我们可以使用更合理的HTML标签。 记住，DOM操作是非常损耗性能的。  </p><h4 id="十二-避免重定向"><a href="#十二-避免重定向" class="headerlink" title="十二.避免重定向"></a>十二.避免重定向</h4><p>当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。由于重定向会触发额外的HTTP请求响应周期，并会额外延长往返时间延迟，因此，将应用发出的重定向数量降至最低至关重要。避免HTTP重定向可以缩减用户等待网页加载的时间。 <strong>一些建议</strong> 如果你的网页需要针对桌面版与移动版浏览器提供不同的展现方式，建议优先使用响应式网页设计，自然就可以避免网页重定向了。 <strong>如果你的网页明确要求进行重定向，你应该执行以下两项操作：</strong></p><ul><li>  使用HTTP重定向将使用移动版浏览器的用户直接发送到对应的移动版网址，而不执行任何中间的重定向；</li><li>  并且在你的桌面版网页中加入 &lt;link rel=“alternate”&gt;标记来识别对应的移动版网址，以便搜索引擎“蜘蛛程序”能够找到你的移动版网页。</li></ul><h3 id="十三-使用浏览器缓存"><a href="#十三-使用浏览器缓存" class="headerlink" title="十三.使用浏览器缓存"></a><strong>十三.使用浏览器缓存</strong></h3><p>如果用户会多次访问你的网站，那么静态资源的浏览器缓存可以节省用户的时间。缓存标头应当应用到所有可缓存的静态资源中，而不仅仅是应用到一小部分静态资源（例如，图片）中。可缓存的资源包括JS和CSS文件、图像文件及其他二进制对象文件（媒体文件和PDF文件等）。通常情况下，HTML不是静态资源，默认情况下不应被视为可缓存资源。你应考虑哪些缓存策略适用于你的网站。 为你的服务器启用浏览器缓存。静态资源应该至少有一周的缓存有效期。广告或小部件这类的第三方资源也应该至少有一天的缓存有效期。对于所有可缓存资源，建议进行以下设置：</p><ul><li>  将 Expires设为将来日期，至少为一周，最多为一年（推荐优先设置 Expires，而不设置 Cache-Control: max-age，因为前者受支持的范围更为广泛）。应避免将其设为超过一年的将来日期，因为这样就违反了RFC准则。</li><li>  如果你知道资源将具体在何时发生变化，则可以设置较短的过期日期。然而，如果你认为资源“可能将要发生变化”，但又不知道具体时间，则应设置较长的过期日期，并在资源文件名中使用文件指纹（下面会讲到）。</li></ul><p><strong>Expires和Cache-Control: max-age标头</strong> 这些标头用于指定相应时间段，浏览器可在指定的这段时间内使用已缓存的资源，而无需查看网络服务器是否提供了新版资源。这些缓存标头功能强大，没有任何应用条件限制。在设置这些标头并下载资源后，浏览器不会为资源发出任何GET请求，除非过期日期到期或达到时间最大值，亦或是用户清除了缓存。 <strong>Last-Modifed和ETag标头</strong> 这些标头可用于指定浏览器应如何确定用于缓存的文件是否相同。在 Last-Modified标头中指定的是日期，而在 ETag标头中指定的则可以是唯一标识资源的任意值（通常为文件版本或内容哈希值）。 Last-Modified是功能“较弱”的缓存标头，因为浏览器会使用试探法来确定是否需要从缓存中抓取内容。 借助这些标头，浏览器可以通过在用户明确重新加载页面时发出条件式GET请求，有效地更新其已缓存资源。除非你在服务器端更改资源，否则条件式GET请求不会返回完整的响应，因此相较于完整GET请求，此类请求的延迟较小。 <strong>应该使用哪个缓存标头？</strong> 对于所有可缓存资源，指定一个 Expires或 Cache-Control: max-age以及一个 Last-Modified或 ETag至关重要。你没必要同时指定 Expires和 Cache-Control: max-age，或同时指定 Last-Modified和 ETag。下列代码示例了如何在Nginx中为静态资源配置浏览器缓存：</p><p>location ~ \.(cssjspngjpgjpeggifbmpwebpsvgxmljsonmp3wavmp4pdfswfzip)$ {<br>    # 设置相关静态资源过期和缓存时间为一年<br>    expires 31536000s;<br>    add_header Pragma “public”;<br>    add_header Cache-Control “max-age=31536000, public”;<br>}</p><p><strong>使用文件指纹</strong> 对于偶尔发生变化的资源，我们可以让浏览器缓存相应的资源，直到该资源在服务器上出现变化，而服务器则在此时通知浏览器有新版本可用。我们可以通过为每个版本的资源指定一个唯一网址来实现这一目的。例如，假定我们有一个名为 my_stylesheet.css的资源。我们可以将文件重命名为 my_stylesheet_40dfc26.css。当资源发生变化时，其指纹就会发生变化，对应的网址也会随之更改。网址一经更改，系统就会强制浏览器重新抓取资源。通过指纹，我们甚至可以为变化更为频繁的资源设置一个最大的过期日期。 指纹识别的常用方法是使用对文件内容的哈希值进行编码的128位十六进制数。你可以使用Gulp自动化工具的gulp-rev和gulp-rev-replace等相关插件进行自动化添加文件指纹。 另一个策略是直接为新版应用创建新版目录，然后为版本目录中的各个版本放置所有资源。这样做的缺点是，如果各个版本中的资源未发生变化，则其网址将仍会更改以强制重新下载。使用内容哈希值不会遇到该问题，但这种方法稍微复杂一些。  </p><h4 id="十四-使用cookie-free的独立域名"><a href="#十四-使用cookie-free的独立域名" class="headerlink" title="十四.使用cookie-free的独立域名"></a>十四.使用cookie-free的独立域名</h4><p>当浏览器向服务器请求一张静态的图片前,会先发送同域名下的 cookie，服务器对于这些 cookie 不会做任何处理。因此它们只是在毫无意义的消耗带宽。所以你应该确保对于静态内容的请求是无coockie的请求。将静态资源部署到一个独立的无Cookie(cookie-free)的域名，可以避免不必要的Cookie流量，同时还能在某些浏览器上提升资源请求的并发连接数。 下列代码示例了如何在Nginx中为静态资源设置cookie-free：</p><p>location ~ \.(cssjspngjpgjpeggifbmpwebpsvgxmljsonmp3wavmp4pdfswfzip)$ {<br>    # 为相关静态资源设置cookie-free<br>    fastcgi_hide_header Set-Cookie;<br>    tcp_nodelay off;<br>    break;<br>}</p><p>  <strong>最后还有一些建议</strong> 不要在css中使用@import，它会让一个样式文件去等待另一个样式文件的请求，无形中增加了页面等待时间。 减少无效请求，请求一个不存在的资源，会导致较长的等待和阻塞。</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库如何正确保存密码</title>
    <link href="/2018/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81/"/>
    <url>/2018/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>网站登录总是会涉及到密码的，关于密码最重要的应该就是怎样保护用户的密码。存放用户信息的数据库经常会遭到入侵。最好的办法就是对密码进行加密，即使在被拖库，请求被劫持的情况下也能保障用户的密码不被泄露。 常见的加密方式有md5，SHA，我们知道如果直接对密码进行散列，那么黑客可以队通过获得这个密码的散列值，然后查彩虹表获得用户的密码。所以直接对密码进行md5加密肯定是不够的。聪明的程序员想出了个办法，即使用户的密码很短，只要我在他的短密码后面加上一段很长的字符，再计算 md5 ，那反推出原始密码就变得非常困难了。加上的这段长字符，我们称为盐（Salt），通过这种方式加密的结果，我们称为 加盐 Hash 。比如：</p><p>md5(md5(password)+salt)</p><span id="more"></span><p>常用的哈希函数中，SHA-256、SHA-512 会比 md5 更安全，更难破解，出于更高安全性的考虑，会使用 SHA-512 代替 md5 。</p><p>SHA512(SHA512(password)+salt)</p><p>通过上面的加盐哈希运算，即使攻击者拿到了最终结果，也很难反推出原始的密码。不能反推，但可以正着推，假设攻击者将 salt 值也拿到了，那么他可以枚举遍历所有密码，加盐哈希，计算出一个结果对照表，从而破解出简单的密码。这就是通常所说的暴力破解。 关于加盐哈希的过程中经常会犯的错误： 最常见的错误就是在多次哈希加密中使用相同的盐值或者太短的盐值。 每次哈希加密都使用相同的盐值是很容易犯的一个错误，这个盐值要么被硬编码到程序里，要么只在第一次使用时随机获得。这样加盐的方式是做无用功，因为两个相同的密码依然会得到相同的哈希值。攻击者仍然可以使用反向查表法对每个值进行字典攻击，只需要把盐值应用到每个猜测的密码上再进行哈希即可。如果盐值被硬编码到某个流行的软件里，可以专门为这个软件制作查询表和彩虹表，那么破解它生成的哈希值就变得很简单了。 用户创建账户或每次修改密码时，都应该重新生成新的盐值进行加密。 如果盐值太短，攻击者可以构造一个查询表包含所有可能的盐值。以只有3个ASCII字符的盐值为例，一共有95x95x95=857,375种可能。这看起来很多，但是如果对于每个盐值查询表只包含1MB最常见的密码，那么总共只需要837GB的储存空间。一个不到100美元的1000GB硬盘就能解决问题。 同样地，用户名也不应该被用作盐值。尽管在一个网站中用户名是唯一的，但是它们是可预测的，并且经常重复用于其他服务中。攻击者可以针对常见用户名构建查询表，然后对用户名盐值哈希发起进攻。 为了使攻击者无法构造包含所有可能盐值的查询表，盐值必须足够长。一个好的做法是使用和哈希函数输出的字符串等长的盐值，比如SHA256算法的输出是256bits(32 bytes)，那么盐值也至少应该是32个随机字节。 对于每个用户的每个密码，盐值都应该是独一无二的。每当有新用户注册或者修改密码，都应该使用新的盐值进行加密。并且这个盐值也应该足够长，使得有足够多的盐值以供加密。一个好的标准的是：盐值至少和哈希函数的输出一样长；盐值应该被储存和密码哈希一起储存在账户数据表中。 <strong>在Web程序中，永远在服务器端进行哈希加密</strong> 这并不是说你不应该在浏览器端进行加密，但是如果你这么做了，一定要在服务端再次加密。在浏览器中进行哈希加密是个好想法，不过实现的时候注意下面几点： • 客户端密码哈希并<strong>不能代替</strong>HTTPS（SSL/TLS）。如果浏览器和服务器之间的连接是不安全的，那么中间人攻击可以修改JavaScript代码，删除加密函数，从而获取用户密码。 • 有些浏览器不支持JavaScript，也有的用户禁用了浏览器的JavaScript功能。为了最好的兼容性，你的程序应该检测JavaScript是否可用，如果答案为否，需要在服务端模拟客户端的加密。 • 客户端哈希同样需要加盐，很显然的办法就是向服务器请求用户的盐值，但是不要这么做。因为这给了坏蛋一个机会，能够在不知道密码的情况下检测用户名是否有效。既然你已经在服务端对密码进行了加盐哈希，那么在客户端把用户名（或邮箱）加上网站特有的字符串（如域名）作为盐值是可行的。   <strong>让密码更难破解：慢哈希函数</strong> 加盐使攻击者无法采用特定的查询表和彩虹表快速破解大量哈希值，但是却不能阻止他们使用字典攻击或暴力攻击。高端的显卡（GPU）和定制的硬件可以每秒进行数十亿次哈希计算，因此这类攻击依然可以很高效。为了降低攻击者的效率，我们可以使用一种叫做<strong>密钥扩展</strong>的技术。 这种技术的思想就是把哈希函数变得很慢，于是即使有着超高性能的GPU或定制硬件，字典攻击和暴力攻击也会慢得让攻击者无法接受。最终的目标是把哈希函数的速度降到足以让攻击者望而却步，但造成的延迟又不至于引起用户的注意。比如：bcrypt 就是这样一个慢哈希函数：</p><p>bcrypt(SHA512(password),salt,cost)</p><p>通过调整 cost 参数，可以调整该函数慢到什么程度。假设让 bcrypt 计算一次需要 0.5 秒，遍历 6 位的简单密码，需要的时间为：((26 * 2 + 10)^6) / 2 秒，约 900 年。 好了，有了上面的基础，来看看我的最终解决方案： <img src="https://www.zhchi.me/wp-content/uploads/2018/02/pwd-300x233.jpg"> 上图里有很多细节，我分阶段来讲： <strong>1. 协商密钥</strong> 基于非对称加密的密钥协商算法，可以在通信内容完全被公开的情况下，双方协商出一个只有双方才知道的密钥，然后使用该密钥进行对称加密传输数据。比如图中所用的 ECDH 密钥协商。 <strong>2. 请求 Salt</strong></p><p>双方协商出一个密钥 SharedKey 之后，就可以使用 SharedKey 作为 AES 对称加密的密钥进行通信，客户端传给服务端自己的公钥 A ，以及加密了的用户ID（uid）。服务端从数据库中查找到该 uid 对于的 Salt1 和 Salt2 ，然后再加密返回给客户端。</p><p>注意，服务端保存的 Salt1 和 Salt2 最好和用户数据分开存储，存到其他服务器的数据库里，这样即使被 SQL 注入，想要获得 Salt1 和 Salt2 也会非常困难。</p><p><strong>3. 验证密码</strong></p><p>这是最重要的一步了。客户端拿到 Salt1 和 Salt2 之后，可以计算出两个加盐哈希：</p><p>SaltHash1 = bcrypt(SHA512(password), uid + salt1, 10)<br>SaltHash2 = SHA512(SaltHash1 + uid + salt2)</p><p>使用 SaltHash2 做为 AES 密钥，加密包括 uid，time，SaltHash1，RandKey 等内容传输给服务端：</p><p>Ticket = AES(SaltHash2, uid + time + SaltHash1 + RandKey)<br>AES(SharedKey, Ticket)</p><p>服务端使用 SharedKey 解密出 Ticket 之后，再从数据库中找到该 uid 对应的 SaltHash2 ，解密 Ticket ，得到 SaltHash1 ，使用 SaltHash1 重新计算 SaltHash2 看是否和数据库中的 SaltHash2 一致，从而验证密码是否正确。 校验两个哈希值是否相等时，使用时间恒定的比较函数，防止试探性攻击。 time 用于记录数据包发送的时间，用来防止录制回放攻击。</p><p><strong>4. 加密传输</strong></p><p>密码验证通过后，服务端生成一个随机的临时密钥 TempKey（使用安全的随机函数），并使用 RandKey 做为密钥，传输给客户端。之后双方的数据交互都通过 TempKey 作为 AES 密钥进行加密。</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 中 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 可能为 true 吗？</title>
    <link href="/2018/01/18/javascript-%E4%B8%AD-a-1-a-2-a-3-%E5%8F%AF%E8%83%BD%E4%B8%BA-true-%E5%90%97%EF%BC%9F/"/>
    <url>/2018/01/18/javascript-%E4%B8%AD-a-1-a-2-a-3-%E5%8F%AF%E8%83%BD%E4%B8%BA-true-%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>这是 Stack Overflow 上面的一个问题，乍一看 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 根本不可能嘛。然后看下面答案，觉得真是妙。 目前最高赞的答案是这个：</p><p>const a = {<br>  i: 1,<br>  toString: function () {<br>    return a.i++;<br>  }<br>}</p><p>if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {<br>  console.log(‘Hello World!’);<br>}</p><span id="more"></span><p>排在后面的分别是这几个答案：</p><p>var i = 0;</p><p>with({<br>  get a() {<br>    return ++i;<br>  }<br>}) {<br>  if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)<br>    console.log(“wohoo”);<br>}</p><p>with({<br>  get a() {<br>    return Math.floor(Math.random()*4);<br>  }<br>}){<br>  for(var i=0;i&lt;1000;i++){<br>    if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){<br>      console.log(“after “+(i+1)+” trials, it becomes true finally!!!”);<br>      break;<br>    }<br>  }<br>}</p><p>var val = 0;<br>Object.defineProperty(window, ‘a’, {<br>  get: function() {<br>    return ++val;<br>  }<br>});<br>if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {<br>  console.log(‘yay’);<br>}</p><p>  <a href="https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true">最后附上 Stack Overflow的链接</a> 不过我觉得如果谁真的在开发项目中使用这个的话，会被打死的吧。</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库分页查询的几种方法</title>
    <link href="/2017/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2017/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>1、 基于MySql的LIMIT和Oracle的ROWNUM，可以直接限制返回区间（以MySql为例，注意使用Oracle的ROWNUM时要应用子查询）： <strong>方法一、直接限制返回区间</strong></p><p>SELECT * FROM table WHERE 查询条件 ORDER BY 排序条件 LIMIT ((页码-1)*页大小),页大小;</p><span id="more"></span><p>优点：写法简单。 缺点：当页码和页大小过大时，性能明显下降。 适用：数据量不大。 2、基于LIMIT（MySql）、ROWNUM（Oracle）和TOP（SqlServer），他们可以限制返回的行数，因此可以得到以下两套通用的方法（以SqlServer为例）： <strong>方法二、NOT IN</strong></p><p>SELECT TOP 页大小 * FROM table WHERE 主键 NOT IN<br>(<br>    SELECT TOP (页码-1)*页大小 主键 FROM table WHERE 查询条件 ORDER BY 排序条件<br>)<br>ORDER BY 排序条件</p><p>优点：通用性强。 缺点：当数据量较大时向后翻页，NOT IN中的数据过大会影响性能。 适用：数据量不大。 <strong>方法三、MAX</strong></p><p>SELECT TOP 页大小 * FROM table WHERE 查询条件 AND id &gt;<br>(<br>    SELECT ISNULL(MAX(id),0) FROM<br>    (<br>        SELECT TOP ((页码-1)*页大小) id FROM table WHERE 查询条件 ORDER BY id<br>    ) AS tempTable<br>)<br>ORDER BY id</p><p>优点：速度快，特别是当id为主键时。 缺点：适用面窄，要求排序条件单一且可比较。 适用：简单排序（特殊情况也可尝试转换成类似可比较值处理）。 3、基于SqlServer和Oracle的ROW_NUMBER()，可以得到返回数据的行号，基于此在限制返回区间得到如下方法（以SqlServer为例）： <strong>方法四、ROW_NUMBER()</strong></p><p>SELECT TOP 页大小 * FROM<br>(<br>    SELECT TOP (页码*页大小) ROW_NUMBER() OVER (ORDER BY 排序条件) AS RowNum, * FROM table WHERE 查询条件<br>) AS tempTable<br>WHERE RowNum BETWEEN (页码-1)*页大小+1 AND 页码*页大小<br>ORDER BY RowNum</p><p>优点：在数据量较大时相比NOT IN有优势。 缺点：小数据量时不如NOT IN。 适用：大部分分页查询需求。</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++web实践（CGI编程）</title>
    <link href="/2017/12/01/cweb%E5%AE%9E%E8%B7%B5%EF%BC%88cgi%E7%BC%96%E7%A8%8B%EF%BC%89/"/>
    <url>/2017/12/01/cweb%E5%AE%9E%E8%B7%B5%EF%BC%88cgi%E7%BC%96%E7%A8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>什么是CGI？CGI（The Common Gateway Interface）：通用网关接口，定义web服务器和客户脚本进行信息交互的一系列标准。 为了了解CGI的概念，让我们来看看当我们单击一个超链接来浏览一个特定的web页或URL的时候，背后会发生什么事？</p><span id="more"></span><p>在进行网页浏览时，通常就是通过一个URL请求一个网页，然后服务器返回这个网页文件给浏览器。浏览器在本地解析该文件渲染成我们看到的网页。然而通常我们看到的网页不是静态网页，也就是说在服务端是没有这个网页文件，它是在网页请求的时候动态生成的，比如PHP/JSP网页。依据你请求的参数不同，所返回的内容不同。 同理，如果是请求一个CGI程序的时候（比如在浏览器直接输入CGI程序的URL，或者提交表单的时候发送给CGI程序），CGI程序负责解析从前端传递过来的参数，理解它的意图然后返回数据，比如返回HTML、XML或JSON等。 CGI（The Common Gateway Interface）是一个标准化的协议，能够使应用程序（通常称为CGI程序或CGI脚本）同web服务器和客户端进行交互。CGI程序能够用Python, PERL, Shell, C or C++等语言来实现。 在PHP和Java大行其道的今天，很多人看来用C++编写CGI是几乎淘汰的技术了（其实这到不然，只是比较小众罢了）。所以如果你对C/C++感兴趣或者对历史感兴趣都可以继续阅读下去。 下图简单的展示了CGI程序架构 <img src="https://www.zhchi.me/wp-content/uploads/2017/12/0_1329878110TxXs-300x108.png"> 在你着手写CGI程序之前，确保你的web服务器支持CGI程序并且配置成处理CGI程序。所有的能够被HTTP服务器执行的CGI程序都被存放在预先配置好的目录下面，这个目录叫做CGI目录，并且按照约定命名为 /var/www/cgi-bin，并且约定CGI文件的后缀名为.cgi ，尽管它们是c++可执行文件。 一般的，Apache 服务器在/var/www/cgi-bin目录下配置文件来运行CGI程序，如果你想要声明另外的目录来运行CGI脚本，你需要修改httpd.conf 文件中的部分内容：</p><p>&lt;Directory “/var/www/cgi-bin”&gt;<br>    AllowOverride None<br>    Options ExecCGI<br>    Order allow,deny<br>    Allow from all<br></Directory></p><p>&lt;Directory “/var/www/cgi-bin”&gt;<br>    Options All<br></Directory></p><p>配置好之后。就可以用C/C++编程了！ 第一步：我们编写一个这样的文件</p><p>#include&lt;stdio.h&gt;<br>int main(int args ,char * argv []) {</p><pre><code>printf(&quot;Content-type:text/html\\n\\n&quot;);printf(&quot;hello world ! 我是cgi &quot;);getchar();</code></pre><p>  return 0;<br>}</p><p>编译，生成一个这样的 hello.exe文件、生成之后，我们将hell.exe的属性改为 hello.cgi，然后将其放置到，自己安装的Apache server文件中的cgi-bin文件下，在浏览器中，再输入<a href="http://localhost/cgi-bin/hello.cgi">http://localhost/cgi-bin/hello.cgi</a>  就可以看到这样的画面   <img src="https://www.zhchi.me/wp-content/uploads/2017/12/QQ%E6%88%AA%E5%9B%BE20171201151046-300x130.png"> 那我们该如何用c/c++写一个cgi来做后台，在背后来操作这个数据呢！ 首先，我们需要写一个html。</p><!DOCTYPE html><html><head><meta charset="UTF-8"></head><body><h1>表单提交</h1>  <form action="/cgi-bin/cmd.cgi" method="post" id=CGI>       输入命令：    <input type="text" name="textlist"/>     <input type="submit" value="OK"/></form> </body></html><p>运行效果如图： <img src="https://www.zhchi.me/wp-content/uploads/2017/12/QQ%E6%88%AA%E5%9B%BE20171201151341-300x134.png"> 最后就是重点了！ 像上面写的cgi一样！ 写一个下面这样的代码：</p><p>#define  _CRT_SECURE_NO_WARNINGS<br>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>//#include<stdexcept><br>#include&lt;windows.h&gt;</p><p>//以调用System为举例<br>void func(char ps []) {<br>    // ps 为cmd命令<br>    char *pl = strchr(ps,’=’);  //pl指向当前的位置<br>    if(pl!=NULL)   ps = ps + (pl-ps+1);<br>     printf(“命令cmd = %s\n”, ps);<br>    char cmd[256] = {‘\0’};<br>    char  filename[]  = “Tcmd.txt”;   //暂定放置于当前目录。<br>    sprintf(cmd,”%s &gt; %s “,ps,filename);  //将ps的内容写入cmd中<br>    //生成了一条指令<br>    //无论是否执行成功，都会生成一个Tcmd.txt文件<br>    FILE *fp = NULL;<br>    int tag=system(cmd);<br>    if (tag == 1) {<br>        printf(“命令格式错误！，请重新输入： “);<br>        goto loop;<br>    }<br>    if ((fp = fopen(filename, “r”)) == NULL) {<br>        printf(“没有发现文件！”);<br>        goto loop ;<br>     }</p><pre><code> while (!feof(fp)) &#123;     char str=fgetc(fp);      if (str == &#39;\\n&#39;) printf(&quot;&lt;br&gt;&lt;br&gt;\\n\\n&quot;);      else if (str == &#39; &#39;)printf(&quot;&amp;nbsp;&quot;);      else          printf(&quot;%c&quot;,str); &#125;</code></pre><p> loop:<br>     if (fp != NULL){<br>         fclose(fp);<br>         //并删除备份的文件<br>         system(“del Tcmd.txt”);<br>     }<br>     return ;<br>}</p><p>int main(int args ,char * argv []) {</p><pre><code>printf(&quot;Content-type:text/html\\n\\n&quot;);//打印环境变量printf(&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;%s&lt;br&gt;&lt;br&gt;&quot;, getenv(&quot;QUERY\_STRING&quot;));char szPost\[256\] = &#123;&#39;\\0&#39;&#125;;gets(szPost);  //获取输入    if ( strlen(szPost) &lt; 1 )    strcpy( szPost , &quot;ipconfig&quot; );func(szPost);getchar();</code></pre><p>  return 0;<br>}</p><p>编译之后，形成cmd.exe，将cmd.exe属性改为cmd.cgi文件，放置到cgi-bin目录中，当然，如果有服务器，之间放到服务器中就可以看！ 然后打开浏览器就能访问了，在输入框里输入cmd命令再点击ok就能预览效果了。 <img src="https://www.zhchi.me/wp-content/uploads/2017/12/QQ%E6%88%AA%E5%9B%BE20171201151743-270x300.png"> <img src="https://www.zhchi.me/wp-content/uploads/2017/12/QQ%E6%88%AA%E5%9B%BE20171201151804-222x300.png"> CGI是一种标准，并不限定语言。所以Java、PHP、Python都可以通过这种方式来生成动态网页。但是实际上这些动态语言却很少这样用。原来是CGI有一大硬伤。那就是每次CGI请求，那么Apache都有启动一个进程去执行这个CGI程序，即颇具Unix特色的fork-and-execute。当用户请求量大的时候，这个fork-and-execute的操作会严重拖慢Server的进程。而Java的Servlet技术则是一种常驻内存的技术，不会频繁的发生进程上下文的创建和销毁操作。 时势造英雄，FastCGI技术应运而生。简单来说，其本质就是一个常驻内存的进程池技术，由调度器负责将传递过来的CGI请求发送给处理CGI的handler进程来处理。在一个请求处理完成之后，该处理进程不销毁，继续等待下一个请求的到来。FCGI技术一出，CGI又一定程度上焕发了第二春。PHP-FPM本身是使PHP支持FCGI技术的一个Patch，现在已经被纳入PHP标准。当然，支持C++的FCGI技术也出现了，Apache有FCGI的模块可以安装，比如mod_fcgid。 前面我们知道，CGI可以直接返回一个html网页。CGI程序本身也可以进行各种计算、逻辑处理任务。随着各类web前后端技术的发展，以及大数据、高并发的Server使用场景越来越多。现代的CGI的用法，在发生变化。 现在，越来越多的任务从后端转移到前端，前端页面利用丰富的Js技术来进行更多的处理。 JS可以使用Ajax技术来向后台CGI发起数据请求。Ajax完成的是不需要刷新整个页面就可以加载后端数据（比如从数据库中取出）。 CGI一般不再用于直接返回html页面，同时将复杂的计算、IO任务下沉到后端（后端可以进一步进行路由转发，实现负载均衡）。使CGI作为前后端之间的中间层。彼时CGI的职能是完成基本的数据交换：解析前端数据请求，再转发给对应后端；然后从后端取回数据，给前端返回XML或JSON。 前端JS利用XML/JSON中的数据来进行填充，绘制出丰富的页面。</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>css3绘制基本图形</title>
    <link href="/2017/11/23/css3%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2/"/>
    <url>/2017/11/23/css3%E7%BB%98%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p>#css3-circle{width: 150px;height: 150px;border-radius: 50%;background-color: #232323;} #css3-elipse{width: 200px;height: 100px;border-radius: 50%;background-color: #232323;} #css3-triangle{width: 0;height: 0;border-left: 100px solid transparent;border-right: 100px solid transparent;border-bottom: 150px solid #232323;} #css3-parallelogram{width: 200px;height: 100px;background: #232323;-webkit-transform: skew(-45deg);-moz-transform: skew(-45deg);-o-transform: skew(-45deg);transform: skew(-45deg);} #css3-trapezoid{width: 100px;height: 0;border-bottom: 100px solid #232323;border-left: 50px solid transparent;border-right: 50px solid transparent;} #css3-six-star{width: 0;height: 0;position: relative;border-bottom: 100px solid #232323;border-left: 50px solid transparent;border-right: 50px solid transparent;} #css3-six-star:after{content: “”;width: 0;height: 0;position: absolute;left: -50px;top: 35px;border-top: 100px solid #232323;border-left: 50px solid transparent;border-right: 50px solid transparent;} #css3-five-star{width: 0px;height: 0px;margin: 50px 0;position: relative;display: block;color: #232323;border-right: 100px solid transparent;border-bottom: 70px solid #232323;border-left:100px solid transparent;-moz-transform:rotate(35deg);-webkit-transform: rotate(35deg);-ms-transform:rotate(35deg);-o-transform:rotate(35deg);} #css3-five-star:before{border-bottom: 80px solid #232323;;border-left: 30px solid transparent;border-right: 30px solid transparent;position: absolute;height: 0;width: 0;top: -45px;left: -63px;display: block;content: ‘’;-webkit-transform: rotate(-35deg);-moz-transform:rotate(-35deg);-ms-transform:rotate(-35deg);-o-transform:rotate(-35deg);} #css3-five-star:after{position: absolute;display: block;color: #232323;top: 3px;left: -105px;width: 0px;height: 0px;border-right: 100px solid transparent;border-bottom: 70px solid #232323;border-left: 100px solid transparent;-webkit-transform: rotate(-70deg);-moz-transform:rotate(-70deg);-ms-transform:rotate(-70deg);-o-transform:rotate(-70deg);content: ‘’;} #css3-pentagon {position: relative;width: 54px;border-width: 50px 18px 0;border-style: solid; border-color: #232323 transparent;box-sizing:content-box !important;} #css3-pentagon:before {content: “”;position: absolute;height: 0;width: 0;top: -85px;left: -18px;border-width: 0 45px 35px;border-style: solid;border-color: transparent transparent #232323;box-sizing:content-box !important;} #css3-hexagon {width: 100px;height: 55px;background: #232323; position: relative;} #css3-hexagon:before {content: “”;position: absolute;top: -25px;left: 0;width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-bottom: 25px solid #232323; } #css3-hexagon:after {content: “”;position: absolute;bottom: -25px;left: 0;width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-top: 25px solid #232323; } #css3-heart {position: relative;width: 100px;height: 90px;} #css3-heart:before, #css3-heart:after{position: absolute;content: “”;left: 50px;top: 0;width: 50px;height: 80px;background: #232323;-moz-border-radius: 50px 50px 0 0;border-radius: 50px 50px 0 0;-webkit-transform: rotate(-45deg);-moz-transform: rotate(-45deg);-ms-transform: rotate(-45deg);-o-transform: rotate(-45deg);transform: rotate(-45deg);-webkit-transform-origin: 0 100%;-moz-transform-origin: 0 100%;-ms-transform-origin: 0 100%;-o-transform-origin: 0 100%;transform-origin: 0 100%;} #css3-heart:after {left: 0;-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);-ms-transform: rotate(45deg);-o-transform: rotate(45deg);transform: rotate(45deg);-webkit-transform-origin: 100% 100%;-moz-transform-origin: 100% 100%;-ms-transform-origin: 100% 100%;-o-transform-origin: 100% 100%;transform-origin :100% 100%;} #css3-gossip {width: 96px;height: 48px;background: #f1f1f1;border-color: #232323;border-style: solid;border-width: 2px 2px 50px 2px;border-radius: 100%;position: relative;box-sizing:content-box !important;} #css3-gossip:before{content: “”;position: absolute;top: 50%;left: 0;background: #f1f1f1;border: 18px solid #232323;border-radius: 100%;width: 12px;height: 12px;box-sizing:content-box !important;} #css3-gossip:after {content: “”;position: absolute;top: 50%;left: 50%;background: #232323;border: 18px solid #f1f1f1;border-radius:100%;width: 12px;height: 12px;}</p><p>#css3-circle{<br>width: 150px;<br>height: 150px;<br>border-radius: 50%;<br>background-color: #232323;<br>}</p><span id="more"></span><p>#css3-elipse{<br>width: 200px;<br>height: 100px;<br>border-radius: 50%;<br>background-color: #232323;<br>}</p><p> </p><p>#css3-triangle{<br>width: 0;<br>height: 0;<br>border-left: 100px solid transparent;<br>border-right: 100px solid transparent;<br>border-bottom: 150px solid #232323;<br>}</p><p> </p><p>#css3-parallelogram{<br>width: 200px;<br>height: 100px;<br>background: #232323;<br>-webkit-transform: skew(-45deg);<br>-moz-transform: skew(-45deg);<br>-o-transform: skew(-45deg);<br>transform: skew(-45deg);<br>}</p><p> </p><p>#css3-trapezoid{<br>width: 100px;<br>height: 0;<br>border-bottom: 100px solid #232323;<br>border-left: 50px solid transparent;<br>border-right: 50px solid transparent;<br>}</p><p> </p><p> </p><p>#css3-six-star{<br>width: 0;<br>height: 0;<br>position: relative;<br>border-bottom: 100px solid #232323;<br>border-left: 50px solid transparent;<br>border-right: 50px solid transparent;<br>}</p><p>#css3-six-star:after{<br>content: “”;<br>width: 0;<br>height: 0;<br>position: absolute;<br>left: -50px;<br>top: 35px;<br>border-top: 100px solid #232323;<br>border-left: 50px solid transparent;<br>border-right: 50px solid transparent;<br>}</p><p> </p><p>#css3-five-star{<br>width: 0px;<br>height: 0px;<br>margin: 50px 0;<br>position: relative;<br>display: block;<br>color: #232323;<br>border-right: 100px solid transparent;<br>border-bottom: 70px  solid #232323;<br>border-left:100px solid transparent;<br>-moz-transform:rotate(35deg);<br>-webkit-transform: rotate(35deg);<br>-ms-transform:rotate(35deg);<br>-o-transform:rotate(35deg);<br>}</p><p>#css3-five-star:before{<br>border-bottom: 80px solid #232323;;<br>border-left: 30px solid transparent;<br>border-right: 30px solid transparent;<br>position: absolute;<br>height: 0;<br>width: 0;<br>top: -45px;<br>left: -63px;<br>display: block;<br>content: ‘’;<br>-webkit-transform: rotate(-35deg);<br>-moz-transform:rotate(-35deg);<br>-ms-transform:rotate(-35deg);<br>-o-transform:rotate(-35deg);<br>}</p><p>#css3-five-star:after{<br>position: absolute;<br>display: block;<br>color: #232323;<br>top: 3px;<br>left: -105px;<br>width: 0px;<br>height: 0px;<br>border-right: 100px solid transparent;<br>border-bottom: 70px solid #232323;<br>border-left: 100px solid transparent;<br>-webkit-transform: rotate(-70deg);<br>-moz-transform:rotate(-70deg);<br>-ms-transform:rotate(-70deg);<br>-o-transform:rotate(-70deg);<br>content: ‘’;<br>}</p><p> </p><p> </p><p>#css3-pentagon {<br>position: relative;<br>width: 54px;<br>border-width: 50px 18px 0;<br>border-style: solid;<br>border-color: #232323 transparent;<br>}</p><p>#css3-pentagon:before {<br>content: “”;<br>position: absolute;<br>height: 0;<br>width: 0;<br>top: -85px;<br>left: -18px;<br>border-width: 0 45px 35px;<br>border-style: solid;<br>border-color: transparent transparent #232323;<br>}</p><p> </p><p> </p><p>#css3-hexagon {<br>width: 100px;<br>height: 55px;<br>background: #232323;<br>position: relative;<br>}</p><p>#css3-hexagon:before {<br>content: “”;<br>position: absolute;<br>top: -25px;<br>left: 0;<br>width: 0;<br>height: 0;<br>border-left: 50px solid transparent;<br>border-right: 50px solid transparent;<br>border-bottom: 25px solid #232323;<br>}</p><p>#css3-hexagon:after {<br>content: “”;<br>position: absolute;<br>bottom: -25px;<br>left: 0;<br>width: 0;<br>height: 0;<br>border-left: 50px solid transparent;<br>border-right: 50px solid transparent;<br>border-top: 25px solid #232323;<br>}</p><p> </p><p>#css3-heart {<br>position: relative;<br>width: 100px;<br>height: 90px;<br>}</p><p>#css3-heart:before,<br>#css3-heart:after{<br>position: absolute;<br>content: “”;<br>left: 50px;<br>top: 0;<br>width: 50px;<br>height: 80px;<br>background: #232323;<br>-moz-border-radius: 50px 50px 0 0;<br>border-radius: 50px 50px 0 0;<br>-webkit-transform: rotate(-45deg);<br>-moz-transform: rotate(-45deg);<br>-ms-transform: rotate(-45deg);<br>-o-transform: rotate(-45deg);<br>transform: rotate(-45deg);<br>-webkit-transform-origin: 0 100%;<br>-moz-transform-origin: 0 100%;<br>-ms-transform-origin: 0 100%;<br>-o-transform-origin: 0 100%;<br>transform-origin: 0 100%;<br>}</p><p>#css3-heart:after {<br>left: 0;<br>-webkit-transform: rotate(45deg);<br>-moz-transform: rotate(45deg);<br>-ms-transform: rotate(45deg);<br>-o-transform: rotate(45deg);<br>transform: rotate(45deg);<br>-webkit-transform-origin: 100% 100%;<br>-moz-transform-origin: 100% 100%;<br>-ms-transform-origin: 100% 100%;<br>-o-transform-origin: 100% 100%;<br>transform-origin :100% 100%;<br>} </p><p> </p><p>#css3-gossip {<br>width: 96px;<br>height: 48px;<br>background: #f1f1f1;<br>border-color: #232323;<br>border-style: solid;<br>border-width: 2px 2px 50px 2px;<br>border-radius: 100%;<br>position: relative;<br>}</p><p>#css3-gossip:before{<br> content: “”;<br> position: absolute;<br> top: 50%;<br> left: 0;<br> background: #f1f1f1;<br> border: 18px solid #232323;<br> border-radius: 100%;<br> width: 12px;<br> height: 12px;<br>}</p><p>#css3-gossip:after {<br>content: “”;<br>position: absolute;<br>top: 50%;<br>left: 50%;<br>background: #232323;<br>border: 18px solid #f1f1f1;<br>border-radius:100%;<br>width: 12px;<br>height: 12px;<br>}</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么浏览器User-agent总是有Mozilla字样</title>
    <link href="/2017/11/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%8F%E8%A7%88%E5%99%A8user-agent%E6%80%BB%E6%98%AF%E6%9C%89mozilla%E5%AD%97%E6%A0%B7/"/>
    <url>/2017/11/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%8F%E8%A7%88%E5%99%A8user-agent%E6%80%BB%E6%98%AF%E6%9C%89mozilla%E5%AD%97%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<p>你是否好奇标识浏览器身份的User-Agent，为什么每个浏览器都有Mozilla字样？</p><p>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36<br>Mozilla/5.0 (Linux; U; Android 4.1.2; zh-tw; GT-I9300 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30<br>Mozilla/5.0 (Windows NT 6.1; WOW64; rv:20.0) Gecko/20100101 Firefox/20.0<br>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0; Trident/5.0)</p><span id="more"></span><p>故事还得从头说起，最初的主角叫NCSA Mosaic，简称Mosaic（马赛克），是1992年末位于伊利诺伊大学厄巴纳-香槟分校的国家超级计算机应用中心（National Center for Supercomputing Applications，简称NCSA）开发，并于1993年发布的一款浏览器。它自称“_NCSA_Mosaic/2.0（Windows 3.1）_”，Mosaic可以同时展示文字和图片，从此浏览器变得有趣多了。 然而很快就出现了另一个浏览器，这就是著名的Mozilla，中文名称摩斯拉。一说 Mozilla = Mosaic + Killer，意为Mosaic杀手，也有说法是 Mozilla = Mosaic &amp; Godzilla，意为马赛克和哥斯拉，而Mozilla最初的吉祥物是只绿色大蜥蜴，后来更改为红色暴龙，跟哥斯拉长得一样。 但Mosaic对此非常不高兴，于是后来Mozilla更名为Netscape，也就是网景。Netscape自称“_Mozilla/1.0(Win3.1)_”，事情开始变得更加有趣。网景支持框架（frame），由于大家的喜欢框架变得流行起来，但是Mosaic不支持框架，于是网站管理员探测user agent，对Mozilla浏览器发送含有框架的页面，对非Mozilla浏览器发送没有框架的页面。 后来网景拿微软寻开心，称微软的Windows是“没有调试过的硬件驱动程序”。微软很生气，后果很严重。此后微软开发了自己的浏览器，这就是Internet Explorer，并希望它可以成为Netscape Killer。IE同样支持框架，但它不是Mozilla，所以它总是收不到含有框架的页面。微软很郁闷很快就沉不住气了，它不想等到所有的网站管理员都了解IE并且给IE发送含有框架的页面，它选择宣布IE是兼容Mozilla，并且模仿Netscape称IE为“_Mozilla/1.22(compatible; MSIE 2.0; Windows 95)_”，于是IE可以收到含有框架的页面了，所有微软的人都嗨皮了，但是网站管理员开始晕了。 因为微软将IE和Windows捆绑销售，并且把IE做得比Netscape更好，于是第一次浏览器血腥大战爆发了，结果是Netscape以失败退出历史舞台，微软更加嗨皮。但没想到Netscape居然以Mozilla的名义重生了，并且开发了Gecko，这次它自称为“_Mozilla/5.0(Windows; U; Windows NT 5.0; en-US; rv:1.1) Gecko/20020826_”。 Gecko是一款渲染引擎并且很出色。Mozilla后来变成了Firefox，并自称“_Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0_”。Firefox性能很出色，Gecko也开始攻城略地，其他新的浏览器使用了它的代码，并且将它们自己称为“_Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.7.2) Gecko/20040825 Camino/0.8.1_”，以及“_Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.8) Gecko/20071008 SeaMonkey/1.0_”，每一个都将自己装作Mozilla，而它们全都使用Gecko。 Gecko很出色，而IE完全跟不上它，因此user agent探测规则变了，使用Gecko的浏览器被发送了更好的代码，而其他浏览器则没有这种待遇。Linux的追随者对此很难过，因为他们编写了Konqueror，它的引擎是KHTML，他们认为KHTML和Gecko一样出色，但却因为不是Gecko而得不到好的页面，于是Konqueror为得到更好的页面开始将自己伪装成“like Gecko”，并自称为“_Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)_”。自此user agent变得更加混乱。 这时更有Opera跳出来说“毫无疑问，我们应该让用户来决定他们想让我们伪装成哪个浏览器。”于是Opera干脆创建了菜单项让用户自主选择让Opera浏览器变成“_Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51_”，或者“_Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51_”， 或者“_Opera/9.51 (Windows NT 5.1; U; en)<em>”。 后来苹果开发了Safari浏览器，并使用KHTML作为渲染引擎，但苹果加入了许多新的特性，于是苹果从KHTML另辟分支称之为WebKit，但它又不想抛弃那些为KHTML编写的页面，于是Safari自称为“_Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5_”，这进一步加剧了user agent的混乱局面。 因为微软十分忌惮Firefox，于是IE重装上阵，这次它自称为“_Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)</em> ”，并且渲染效果同样出色，但是需要网站管理员的指令它这么做才行。 再后来，谷歌开发了Chrome浏览器，Chrome使用Webkit作为渲染引擎，和Safari之前一样，它想要那些为Safari编写的页面，于是它伪装成了Safari。于是Chrome使用WebKit，并将自己伪装成Safari，WebKit伪装成KHTML，KHTML伪装成Gecko，最后所有的浏览器都伪装成了Mozilla，这就是为什么所有的浏览器User-Agent里都有Mozilla。Chrome自称为“_Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13_”。 因为以上这段历史，现在的User-Agent字符串变得一团糟，几乎根本无法彰显它最初的意义。追根溯源，微软可以说是这一切的始作俑者，但后来每一个人都在试图假扮别人，最终把User-Agent搞得混乱不堪。 一句话结论：因为网站开发者可能会因为你是某浏览器（这里是 Mozilla），所以输出一些特殊功能的程序代码（这里指好的特殊功能），所以当其它浏览器也支持这种好功能时，就试图去模仿 Mozilla 浏览器让网站输出跟 Mozilla 一样的内容，而不是输出被阉割功能的程序代码。大家都为了让网站输出最好的内容，都试图假装自己是 Mozilla 一个已经不存在的浏览器…… 附各大浏览器诞生年表：</p><ul><li>  1993年1月23日：Mosaic</li><li>  1994年12月：Netscape</li><li>  1994年：Opera</li><li>  1995年8月16日：Internet Explorer</li><li>  1996年10月14日：Kongqueror</li><li>  2003年1月7日：Safari</li><li>  2008年9月2日：Chrome</li></ul><p>本文转自简明现代魔法</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket——javascript例子</title>
    <link href="/2017/11/11/websocket/"/>
    <url>/2017/11/11/websocket/</url>
    
    <content type="html"><![CDATA[<h3 id="一、详细代码案例"><a href="#一、详细代码案例" class="headerlink" title="一、详细代码案例"></a>一、详细代码案例</h3><p>详细解读一个简单html5 WebSocket的Js实例教程,附带完整的javascript websocket实例源码，以及实例代码效果演示页面，并对本实例的核心代码进行了深入解读。从WebSocket通讯三个阶段（打开握手、数据传递、关闭握手）进行了探讨，各阶段中浏览器和服务器做了些什么事情也有所涉及。</p><p>//检查浏览器是否支持WebSocket<br>    if(window.WebSocket){<br>        console.log(‘This browser supports WebSocket’);<br>    }else{<br>        console.log(‘This browser does not supports WebSocket’);<br>    }</p><span id="more"></span><!DOCTYPE html><meta charset="utf-8" />  <title>WebSocket Test</title>  <script language="javascript"type="text/javascript">      var wsUri ="ws://echo.websocket.org/";     var output;      <pre><code>function init() &#123;     output = document.getElementById(&quot;output&quot;);     testWebSocket(); &#125;  function testWebSocket() &#123;     websocket = new WebSocket(wsUri);     websocket.onopen = function(evt) &#123;         onOpen(evt)     &#125;;     websocket.onclose = function(evt) &#123;         onClose(evt)     &#125;;     websocket.onmessage = function(evt) &#123;         onMessage(evt)     &#125;;     websocket.onerror = function(evt) &#123;         onError(evt)     &#125;; &#125;  function onOpen(evt) &#123;     writeToScreen(&quot;CONNECTED&quot;);     doSend(&quot;WebSocket rocks&quot;); &#125;  function onClose(evt) &#123;     writeToScreen(&quot;DISCONNECTED&quot;); &#125;  function onMessage(evt) &#123;     writeToScreen(&#39;&lt;span style=&quot;color: blue;&quot;&gt;RESPONSE: &#39;+ evt.data+&#39;&lt;/span&gt;&#39;);     websocket.close(); &#125;  function onError(evt) &#123;     writeToScreen(&#39;&lt;span style=&quot;color: red;&quot;&gt;ERROR:&lt;/span&gt; &#39;+ evt.data); &#125;  function doSend(message) &#123;     writeToScreen(&quot;SENT: &quot; + message);      websocket.send(message); &#125;  function writeToScreen(message) &#123;     var pre = document.createElement(&quot;p&quot;);     pre.style.wordWrap = &quot;break-word&quot;;     pre.innerHTML = message;     output.appendChild(pre); &#125;  window.addEventListener(&quot;load&quot;, init, false);  </code></pre><p></script>  </p><h2>WebSocket Test</h2>  <div id="output"></div>  </html><h3 id="二、主要代码解读："><a href="#二、主要代码解读：" class="headerlink" title="二、主要代码解读："></a>二、主要代码解读：</h3><h4 id="1、申请一个WebSocket对象"><a href="#1、申请一个WebSocket对象" class="headerlink" title="1、申请一个WebSocket对象"></a><strong>1、申请一个WebSocket对象</strong></h4><p>参数是需要连接的服务器端的地址，同http协议使用http://开头一样，WebSocket协议的URL使用ws://开头，另外安全的WebSocket协议使用wss://开头。</p><p>var wsUri =”ws://echo.websocket.org/“;<br>websocket = new WebSocket(wsUri);</p><h4 id="2、WebSocket对象一共支持四个消息-onopen-onmessage-onclose和onerror"><a href="#2、WebSocket对象一共支持四个消息-onopen-onmessage-onclose和onerror" class="headerlink" title="2、WebSocket对象一共支持四个消息 onopen, onmessage, onclose和onerror"></a><strong>2、WebSocket对象一共支持四个消息 onopen, onmessage, onclose和onerror</strong></h4><p>我们可以看出所有的操作都是采用消息的方式触发的，这样就不会阻塞UI，使得UI有更快的响应时间，得到更好的用户体验。 （1）当Browser和WebSocketServer连接成功后，会触发onopen消息;</p><p>websocket.onopen = function(evt) {};</p><p>（2）如果连接失败，发送、接收数据失败或者处理数据出现错误，browser会触发onerror消息;</p><p>websocket.onerror = function(evt) { };</p><p>（3）当Browser接收到WebSocketServer发送过来的数据时，就会触发onmessage消息，参数evt中包含server传输过来的数据;</p><p>websocket.onmessage = function(evt) { };</p><p>（4）当Browser接收到WebSocketServer端发送的关闭连接请求时，就会触发onclose消息。</p><p>websocket.onclose = function(evt) { };</p><h4 id="3、通信协议"><a href="#3、通信协议" class="headerlink" title="3、通信协议"></a><strong>3、通信协议</strong></h4><p>WebSocket与TCP、HTTP的关系WebSocket与http协议一样都是基于TCP的，所以他们都是可靠的协议，Web开发者调用的WebSocket的send函数在browser的实现中最终都是通过TCP的系统接口进行传输的。 WebSocket和Http协议一样都属于应用层的协议，那么他们之间有没有什么关系呢?答案是肯定的，WebSocket在建立握手连接时，数据是通过http协议传输的，但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的。 <img src="https://zhchi.me/wp-content/uploads/2017/11/1500947473730_1828_1500947473902-300x129.png"></p><h3 id="三、WebSocket通讯详细解读："><a href="#三、WebSocket通讯详细解读：" class="headerlink" title="三、WebSocket通讯详细解读："></a>三、WebSocket通讯详细解读：</h3><p>从下图可以明显的看到，分三个阶段： 1.打开握手 2.数据传递 3.关闭握手 <img src="https://zhchi.me/wp-content/uploads/2017/11/1500947507792_736_1500947508191-300x294.png"> 下图显示了WebSocket主要的三步 浏览器和 服务器端分别做了那些事情。 <img src="https://zhchi.me/wp-content/uploads/2017/11/13210729-8958924643cd45208f6d228d6a0e73e1-300x225.png"></p><h3 id="四、WebSocket的优点"><a href="#四、WebSocket的优点" class="headerlink" title="四、WebSocket的优点"></a>四、WebSocket的优点</h3><p>a)、服务器与客户端之间交换的标头信息很小，大概只有2字节; b)、客户端与服务器都可以主动传送数据给对方; c)、不用频率创建TCP请求及销毁请求，减少网络带宽资源的占用，同时也节省服务器资源;</p><h3 id="五、建立连接的握手"><a href="#五、建立连接的握手" class="headerlink" title="五、建立连接的握手"></a>五、建立连接的握手</h3><p><strong>当Web应用程序调用new WebSocket(url)接口时，Browser就开始了与地址为url的WebServer建立握手连接的过程。</strong> 1. Browser与WebSocket服务器通过TCP三次握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用程序将收到错误消息通知。 2. 在TCP建立连接成功后，Browser/UA通过http协议传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。 3. WebSocket服务器收到Browser/UA发送来的握手请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。 4. Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，此时Web开发者就可以在此时通过send接口想服务器发送数据。否则，握手连接失败，Web应用程序会收到onerror消息，并且能知道连接失败的原因。 这个握手很像HTTP，但是实际上却不是，它允许服务器以HTTP的方式解释一部分handshake的请求，然后切换为websocket</p><h3 id="六、数据传输"><a href="#六、数据传输" class="headerlink" title="六、数据传输"></a>六、数据传输</h3><p><strong>WebScoket协议中，数据以帧序列的形式传输。</strong> 考虑到数据安全性，客户端向服务器传输的数据帧必须进行掩码处理。服务器若接收到未经过掩码处理的数据帧，则必须主动关闭连接。 服务器向客户端传输的数据帧一定不能进行掩码处理。客户端若接收到经过掩码处理的数据帧，则必须主动关闭连接。 针对上情况，发现错误的一方可向对方发送close帧(状态码是1002，表示协议错误)，以关闭连接。 关闭WebSocket(握手) <img src="https://zhchi.me/wp-content/uploads/2017/11/websocket4-300x138.png"> 使用Wireshark监控到的上面WebSocket例子的数据。</p><p>GET / HTTP/1.1</p><p>　　Upgrade: websocket</p><p>　　Connection: Upgrade</p><p>　　Host: echo.websocket.org</p><p>　　Origin: null</p><p>　　Pragma: no-cache</p><p>　　Cache-Control: no-cache</p><p>　　Sec-WebSocket-Key: Qcgtb1RJ6HceeTRLPFux/A==</p><p>　　Sec-WebSocket-Version: 13</p><p>　　Sec-WebSocket-Extensions: x-webkit-deflate-frame</p><p>　　Cookie: __utma=9925811.951031439.1365242028.1365980711.1366068689.5; __utmc=9925811; __utmz=9925811.1365242028.1.1.utmcsr=websocket.orgutmccn=(referral)utmcmd=referralutmcct=/</p><p>　　HTTP/1.1 101 Web Socket Protocol Handshake</p><p>　　Upgrade: WebSocket</p><p>　　Connection: Upgrade</p><p>　　Sec-WebSocket-Accept: 84Qpane33QhxOmcz8bGkFdE1AHk=</p><p>　　Server: Kaazing Gateway</p><p>　　Date: Tue, 16 Apr 2013 09:51:25 GMT</p><p>　　Access-Control-Allow-Origin: null</p><p>　　Access-Control-Allow-Credentials: true</p><p>　　Access-Control-Allow-Headers: content-type</p><p>　　Access-Control-Allow-Headers: authorization</p><p>　　Access-Control-Allow-Headers: x-websocket-extensions</p><p>　　Access-Control-Allow-Headers: x-websocket-version</p><p>　　Access-Control-Allow-Headers: x-websocket-protocol</p><p>　　..a[</p><p>　　J6&gt;h..8a/.{x%.0y..WebSocket rocks..i…..</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>webkit浏览器中自定义滚动条的样式</title>
    <link href="/2017/11/09/webkit%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E6%A0%B7%E5%BC%8F/"/>
    <url>/2017/11/09/webkit%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://zhchi.me/wp-content/uploads/2017/11/scrollbar-300x258.png"></p><span id="more"></span><p>::-webkit-scrollbar //滚动条整体部分，其中的属性有width,height,background,border（就和一个块级元素一样）等。（位置1）<br>::-webkit-scrollbar-button //滚动条两端的按钮。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。（位置2）<br>::-webkit-scrollbar-track  // 外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果（位置3）<br>::-webkit-scrollbar-track-piece  //内层轨道，滚动条中间部分（位置4）<br>::-webkit-scrollbar-thumb //滚动条里面可以拖动的那部分（位置5）<br>::-webkit-scrollbar-corner //边角（位置6）<br>::-webkit-resizer //定义右下角拖动块的样式（位置7）</p><p>上面是滚动条的主要几个设置属性，还有更详尽的CSS属性 <strong>:horizontal</strong> 水平方向的滚动条 <strong>:vertical</strong> 垂直 方向的滚动条 <strong>:decrement</strong> 应用于按钮和内层轨道(track piece)。它用来指示按钮或者内层轨道是否会减小视窗的位置(比如，垂直滚动条的上面，水平滚动条的左边。) <strong>:increment</strong> decrement类似，用来指示按钮或内层轨道是否会增大视窗的位置(比如，垂直滚动条的下面和水平滚动条的右边。) <strong>:start</strong> 伪类也应用于按钮和滑块。它用来定义对象是否放到滑块的前面。 <strong>:end</strong> 类似于start伪类，标识对象是否放到滑块的后面。 <strong>:double-button</strong>  该伪类以用于按钮和内层轨道。用于判断一个按钮是不是放在滚动条同一端的一对按钮中的一个。对于内层轨道来说，它表示内层轨道是否紧靠一对按钮。 <strong>:single-button</strong> 类似于double-button伪类。对按钮来说，它用于判断一个按钮是否自己独立的在滚动条的一段。对内层轨道来说，它表示内层轨道是否紧靠一个single-button。 <strong>:no-button</strong> 用于内层轨道，表示内层轨道是否要滚动到滚动条的终端，比如，滚动条两端没有按钮的时候。 <strong>:corner-present</strong>  用于所有滚动条轨道，指示滚动条圆角是否显示。 <strong>:window-inactive</strong> 用于所有的滚动条轨道，指示应用滚动条的某个页面容器(元素)是否当前被激活。(在webkit最近的版本中，该伪类也可以用于::selection伪元素。webkit团队有计划扩展它并推动成为一个标准的伪类)  </p><h1 id="下面是DEMO："><a href="#下面是DEMO：" class="headerlink" title="下面是DEMO："></a>下面是DEMO：</h1><p>/* 设置滚动条的样式 */<br>::-webkit-scrollbar {<br>    width: 12px;<br>}<br>/* 滚动槽 */<br>::-webkit-scrollbar-track {<br>    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);<br>    border-radius: 10px;<br>}<br>/* 滚动条滑块 */<br>::-webkit-scrollbar-thumb {<br>    border-radius: 10px;<br>    background: rgba(0,0,0,0.1);<br>    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.5);<br>}<br>::-webkit-scrollbar-thumb:window-inactive {<br>    background: rgba(255,0,0,0.4);<br>}</p><h2 id="IE下面的CSS设置滚动条"><a href="#IE下面的CSS设置滚动条" class="headerlink" title="IE下面的CSS设置滚动条"></a>IE下面的CSS设置滚动条</h2><p>IE下面就比较简单那了，自定义的项目比较少，全是颜色。</p><ol><li> scrollbar-arrow-color: color; /*三角箭头的颜色*/</li><li> scrollbar-face-color: color; /*立体滚动条的颜色（包括箭头部分的背景色）*/</li><li> scrollbar-3dlight-color: color; /*立体滚动条亮边的颜色*/</li><li> scrollbar-highlight-color: color; /*滚动条的高亮颜色（左阴影？）*/</li><li> scrollbar-shadow-color: color; /*立体滚动条阴影的颜色*/</li><li> scrollbar-darkshadow-color: color; /*立体滚动条外阴影的颜色*/</li><li> scrollbar-track-color: color; /*立体滚动条背景颜色*/</li><li> scrollbar-base-color:color; /*滚动条的基色*/</li></ol>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>fullPage.js文档</title>
    <link href="/2017/11/06/fullpage-js%E6%96%87%E6%A1%A3/"/>
    <url>/2017/11/06/fullpage-js%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>fullPage.js 是一个基于jQuery的插件，它能够很方便、很轻松的制作出全屏网站，主要功能有：1.支持鼠标滚动。2.多个回调函数。3.支持手机、平板触屏事件。4.支持css3动画。5.支持窗口缩放。6.窗口缩放时自动调整。7.可设置滚动宽度、背景颜色、滚动速度、循环选项、回调、文本对齐方式等</p><p><img src="https://www.zhchi.me/wp-content/uploads/2017/11/12442063688939-e1510397278246-300x169.png"></p><span id="more"></span><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>fullPage.js 是一个基于jQuery的插件，它能够很方便、很轻松的制作出全屏网站，主要功能有：</p><ol><li> 支持鼠标滚动</li><li> 多个回调函数</li><li> 支持手机、平板触屏事件</li><li> 支持css3动画</li><li> 支持窗口缩放</li><li> 窗口缩放时自动调整</li><li> 可设置滚动宽度、背景颜色、滚动速度、循环选项、回调、文本对齐方式等</li></ol><h1 id="二、获取方式："><a href="#二、获取方式：" class="headerlink" title="二、获取方式："></a>二、获取方式：</h1><p>github主页：<a href="https://github.com/alvarotrigo/fullPage.js">https://github.com/alvarotrigo/fullPage.js</a> //With bower bower install fullpage.js // With npm npm install fullpage.js</p><h1 id="三、兼容性及大小、版本"><a href="#三、兼容性及大小、版本" class="headerlink" title="三、兼容性及大小、版本"></a>三、兼容性及大小、版本</h1><ol><li> 支持IE8+以上版本的浏览器</li><li> 仅7kb</li><li> 最新版本是V2.9.4</li></ol><h1 id="四、如何使用："><a href="#四、如何使用：" class="headerlink" title="四、如何使用："></a>四、如何使用：</h1><h2 id="1、引入相关文件"><a href="#1、引入相关文件" class="headerlink" title="1、引入相关文件"></a>1、引入相关文件</h2><p>css文件：jquery.fukkPage.css jquery文件：1.6以上版本即可 easing文件：jquery.easing.js，支持更多动画过渡效果的插件,可选的，非必须 fullPage文件：jquery.fullPage.js 注意： 可以使用cdn上的文件，而非本地文件，当部署到自己网站时，可以减轻自己服务器的压力，提高用户的访问速度 可到 <a href="http://www.bootcdn.cn/fullPage.js/">http://www.bootcdn.cn/fullPage.js/</a> 上去搜索fullPage</p><h2 id="2、页面的基本结构"><a href="#2、页面的基本结构" class="headerlink" title="2、页面的基本结构"></a>2、页面的基本结构</h2><div id="fullpage">    <div class="section active" id="section0"><h1>fullPage.js0</h1></div>    <div class="section" id="section1">        <div class="slide active"><h1>1</h1></div>        <div class="slide"><h1>2</h1></div>        <div class="slide"><h1>3</h1></div>        <div class="slide"><h1>4</h1></div>    </div>    <div class="section" id="section2"><h1>fullPage.js2</h1></div>    <div class="section" id="section3"><h1>fullPage.js3</h1></div></div><h2 id="3、要想激活fullpage效果，需要加入："><a href="#3、要想激活fullpage效果，需要加入：" class="headerlink" title="3、要想激活fullpage效果，需要加入："></a>3、要想激活fullpage效果，需要加入：</h2><script type="text/javascript" src="jquery.fullPage.js"></script><script type="text/javascript">    $(document).ready(function () {        $('#fullpage').fullpage({            sectionsColor: \['#1bbc9b', '#4BBFC3', '#7BAABE', 'whitesmoke', '#ccddff'\],            anchors: \['firstPage', 'secondPage', '3rdPage', '4thpage', 'lastPage'\],            menu: '#menu',            scrollingSpeed: 1000        });    });</script><h1 id="五、配置项"><a href="#五、配置项" class="headerlink" title="五、配置项"></a>五、配置项</h1><p>1.sectionColor:</p><p>可以为每一个section设置background-color属性。</p><p>例如：</p><p>$(‘#fullpage’).fullpage({</p><p>sectionColor: [‘green’,’orange’,’gray’,’red’];</p><p>});</p><p>2.controlArrows: 定义是否通过箭头来控制slide幻灯片，默认为true。当我们设置为false，则幻灯片左右两侧的的箭头就会消失，在移动设备上，我盟，可以通过滑动来操作幻灯片。 3.verticalCentered: 每一页的内容是否垂直居中，默认为true。一般我们保持默认值 4.resize: 字体是否随着窗口缩放而缩放，默认为false 5.scrollingSpeed: 滚动速度，单位为毫秒，默认为700 6.anchors: 定义锚链接，默认值为[]。有了锚链接，用户就可以快速打开定位到某一页面。 注意定义锚链接的时候，值不要和页面中任意id或name相同，尤其是在IE浏览器下，而且定义时不需要加# 7.lockAnchors: 是否锁定锚链接，默认为false。如果设置为true，那么定义的锚链接，也就是anchors属性则没有效果，这个配置项使用比较少 8.active： 在页面中为某一个section添加了active之后，默认当窗口打开时会定位到此active，显示当前页 9.easing: 定义页面section滚动的动画方式，默认为easeInOutCubic，如果修改此项，需要引入jquery。easings插件，或者jquery ui。 10.css3: 是否使用css3 transforms来实现滚动效果，默认为true。这个配置项可以提高支持css3的浏览器，比如移动设备等的速度，如果浏览器不支持css3，则会使用jquery来替代css3实现滚动效果。即优雅降级，使用jquery实现动画，一般来说，它的性能不如css动画来得快。 11.loopTop: 滚动到最顶部后是否连续滚动到底部，默认为false。 12.loopBottom： 滚动到最底部后是否连续滚动回顶部，默认为false。 13.loopHorizontal： 横向slider幻灯片是否循环滚动，默认为true。设置为false时，在第一个slider时，没有向左滚动的箭头，不能向左滚动。同理，最后一个slider时，没有向右滚动的箭头，不能向右滚动。 14.autoScrolling： 是否使用插件的滚动方式，默认为true，如果选择false，则会出现浏览器自带的滚动条，将不会按页滚动，而是按照滚动条的默认行为来滚动。 15.scrollBar： 是否包含滚动条，默认为false，如果设置为true，则浏览器自带的滚动条出现，页面滚动时还是按页滚动，但是滚动条的默认行为也有效。 16.paddingTop/paddingBottom： 设置每一个section顶部和底部的padding，默认都为0.一般如果我们需要设置一个固定在顶部或者底部的菜单、导航、元素等，可以使用这两个配置项。 17.fixedElements： 固定的元素，默认为null，需要配置一个jquery选择器。在页面滚动的时候，fixedElements设置的元素固定不动。 18.keyboardScrolling： 是否可以使用键盘方向键导航，默认为true。 19.touchSensitivity： 在移动设备中滑动页面的敏感性，默认为5，是按百分比来衡量，最高为100，越大则越难滑动。 20.continuousVertical: 是否循环滚动，默认为false。如果设置为true，则页面会循环滚动，而不像loopTop或loopBottom那样出现跳动，注意这个属性和loopTop、loopBottom不兼容，不要同时设置。 21.animateAnchor： 锚链接是否可以控制滚动动画，默认为true。如果设置为false，则通过锚链接定位到某个页面显示不再有动画效果。 22.recordHistory: 是否记录历史，默认为true，可以记录页面滚动的历史，通过浏览器的前进后退来导航。注意如果设置了autoScrolling：false，那么这个配置也将被关闭，即设置为false。 23.menu： 绑定菜单，设定的相关属性与anchors的值对应后，菜单可以控制滚动，默认为false。可以设置为菜单的jquery选择器 24.navigation: 是否显示导航，默认为false。如果设置为true，会显示小圆点，作为导航。 25.navigationPosition： 导航小圆点的位置，可以设置为left或right。 26.navigationTooltips: 导航小圆点的tooltips设置鼠标经过时显示的名字，默认为[]，注意按照顺序设置。 27.showActiveTooltip： 是否显示当前页面的导航的tooltip信息，默认为false 28.slidesNavigation： 是否显示横向幻灯片的导航，默认false。 29.slidesNavPosition： 横向幻灯片导航的位置，默认为bottom，可以设置为top或bottom 30.scrollOverflow： 内容超过满屏后是否显示滚动条，默认为false。如果设置为true，则会显示滚动条，如果要滚动查看内容，还需要jquery.slimscroll插件的配合。 31.slimscroll： 插件主要用于模拟传统的浏览器滚动条。 32.sectionSelector： section的选择器，默认为.section。 33.slideSelector： slide的选择器，默认为.slide。</p><h1 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h1><p>1.moveSectionUp(): 向上滚动一页 2.moveSectionDown(): 向下滚动一页 3.moveTo(section,slide): 滚动到第几页，第几个幻灯片，注意，页面是1开始，而幻灯片，是从0开始。 4.slientMoveTo(section,slide): 滚动到第几页，和moveTo一样，但是没有动画效果。 5.moveSlideRight(): 幻灯片向右滚动 6.moveSlideLeft(): 幻灯片向左滚动。 7.slientMoveTo(section,slide): 滚动到第几页，和moveTo一样，但是没有动画效果。 8.moveSlideRight(): 幻灯片向右滚动 9.moveSlideLeft(): 幻灯片向左滚动 10.setAutoScrolling(boolean): 动态设置autoScrolling 11.setLockAnchors(boolean): 动态设置lockAnchors 12.setRecordHistory(boolean): 动态设置recordHistory 13.setScrollingSpeed(milliseconds): 动态设置scrollingSpeed 14.setAllowScrolling(boolean,[directions]): 添加或删除鼠标滚轮/滑动控制，第一个参数true为启用，false为禁用，后面的参数为方向，取值包含all,up,down,left,right,可以使用多个，逗号分隔 比如我们在做一个有奖问答页面，提问的问题在前面的页面有答案，当滚动到最后一页时，不希望用户在滚动回之前的页面查看答案，就可以使用这样的方法。 15.destroy(type) 销毁fullpage特效，type可以不写，或者使用all，不写type，fullpaga给页面添加的样式和html元素还在，如果使用all，则样式、html等全部销毁，页面恢复和不使用fullpage相同的效果。 16.reBuild() 重新更新页面和尺寸，用于通过ajax请求后改变了页面结构之后，重建效果。</p><h1 id="七、fullPage支持延迟加载图片和视频（Lazy-Loading）"><a href="#七、fullPage支持延迟加载图片和视频（Lazy-Loading）" class="headerlink" title="七、fullPage支持延迟加载图片和视频（Lazy Loading）"></a>七、fullPage支持延迟加载图片和视频（Lazy Loading）</h1><h1 id="八、回调函数"><a href="#八、回调函数" class="headerlink" title="八、回调函数"></a>八、回调函数</h1><p>1.afterLoad(anchorLink,index) 滚动到某一section，且滚动结束后，会触发一次此回调函数，函数接受anchorLink和index两个参数，anchorLink是锚链接的名称，index是序号，从1开始计算。 我们可以根据anchorLink和index参数值的判断，触发相应的事件。 2.onleave(index,nextIndex,direction) 在我们离开一个section时，会触发一次此回调函数，接受index、nextIndex和direction 3个参数： index是离开的“页面”的序号，从1开始计算； nextIndex是滚动到的目标“页面”的序号，从1开始计算； direction判断往上滚动还是往下滚动，值是up或down。 通过return false；可以取消滚动 3.afterRender() 页面结构生成后的回调函数，或者说页面初始化完成后的回调函数。 4.afterResize() 浏览器窗口尺寸改变后的回调函数 5.afterSlideLoad(anchorLink,index,slideAnchor,slideIndex) 滚动到某一幻灯片后的回调函数，与afterLoad类似，接受anchorLink、index、slidIndex、direction4个参数。 6.onSlideLeave(anchorLink，index，slideIndex，direction，nextSlideIndex) 在我们离开一个slide时，会触发一次此回调函数，与onLeave类似，接收anchorLink、index、slideIndex、direction4个参数</p><p>  查看demo：<a href="https://www.zhchi.me/works/fullPage.js">https://www.zhchi.me/works/fullPage.js</a></p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML5 桌面通知：Notification API</title>
    <link href="/2017/10/30/html5-notification-api/"/>
    <url>/2017/10/30/html5-notification-api/</url>
    
    <content type="html"><![CDATA[<p>通知可以说是应用中比较常见且重要的功能，私信、在线提问、或者一些在线即时通讯工具我们总是希望第一时间知道对方有了新的反馈，这个时候，就需要页面给予即使的通知。Notification API 是 HTML5 新增的桌面通知 API，用于向用户显示通知信息。该通知是脱离浏览器的，即使用户没有停留在当前标签页，甚至最小化了浏览器，该通知信息也一样会置顶显示出来。 通知效果如图：<img src="https://zhchi.me/wp-content/uploads/2017/10/QQ%E6%88%AA%E5%9B%BE20171030160005-300x80.png"></p><span id="more"></span><h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2><p>Notification.permission 该属性用于表明当前通知显示的授权状态，可能的值包括：</p><ul><li>  default ：不知道用户的选择，默认。</li><li>  granted ：用户允许。</li><li>  denied ：用户拒绝。</li></ul><h2 id="请求权限"><a href="#请求权限" class="headerlink" title="请求权限"></a>请求权限</h2><p>当用户还没选择的时候，我们需要向用户去请求权限。Notification 对象提供了 requestPermission() 方法请求用户当前来源的权限以显示通知。 以前基于回调的语法已经弃用（当然在现在的浏览器中还是能用的），最新的规范已将此方法更新为基于 promise 的语法：</p><p>Notification.requestPermission().then(function(permission) {<br>    if(permission === ‘granted’){<br>        console.log(‘用户允许通知’);<br>    }else if(permission === ‘denied’){<br>        console.log(‘用户拒绝通知’);<br>    }<br>});</p><h2 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a>推送通知</h2><p>获取用户授权之后，就可以推送通知了。</p><p>var notification = new Notification(title, options)</p><p>参数如下：</p><ul><li>  title：通知的标题</li><li>options：通知的设置选项（可选）。<ul><li>  body：通知的内容。</li><li>  tag：代表通知的一个识别标签，相同tag时只会打开同一个通知窗口。</li><li>  icon：要在通知中显示的图标的URL。</li><li>  image：要在通知中显示的图像的URL。</li><li>  data：想要和通知关联的任务类型的数据。</li><li>  requireInteraction：通知保持有效不自动关闭，默认为false。</li></ul></li></ul><p>一旦通知被创建出来，它会立即被显示出来。为了跟踪通知当前的状态，在 <code>Notification</code> 实例层面上会有4个事件被触发：</p><p><code>show：</code></p><p>当通知被显示给用户时触发。</p><p><code>click：</code></p><p>当用户点击通知时触发。</p><p><code>close：</code></p><p>当通知被关闭时触发。</p><p><code>error：</code></p><p>当通知发生错误的时候触发。这通常是因为通知由于某些原因而无法显示。</p><p>这些事件可以通过事件处理跟踪 <code>onshow</code>、<code>onclick</code>、<code>onclose</code> 和 <code>onerror</code>。因为 <code>Notification</code> 同样继承自 <code>EventTarget</code>，因此可以对它调用 <code>addEventListener()</code> 方法。</p><h2 id="关闭通知"><a href="#关闭通知" class="headerlink" title="关闭通知"></a>关闭通知</h2><p>从上面的参数可以看出，并没有一个参数用来配置显示时长的。我想要它 3s 后自动关闭的话，这时可以调用 close() 方法来关闭通知。</p><p>var n = new Notification(‘状态更新提醒’,{<br>    body: ‘你的朋友圈有3条新状态，快去查看吧’<br>})</p><p>setTimeout(function() {<br>    n.close();<br>}, 3000);</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Notification 接口的 onclick属性指定一个事件侦听器来接收 click 事件。当点击通知窗口时会触发相应事件，比如打开一个网址，引导用户回到自己的网站去。</p><p>var n = new Notification(‘状态更新提醒’,{<br>    body: ‘你的朋友圈有3条新状态，快去查看吧’,<br>    data: {<br>        url: ‘<a href="https://zhchi.me&/#39;">https://zhchi.me&#39;</a><br>    }<br>})<br>n.onclick = function(){<br>    window.open(n.data.url, ‘_blank’);      // 打开网址<br>    n.close();                              // 并且关闭通知<br>}</p><p>demo：<a href="https://www.zhchi.me/works/notification/">点击查看demo</a></p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lua快速入门</title>
    <link href="/2017/10/30/lua%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2017/10/30/lua%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>原文出处： <a href="http://tylerneylon.com/a/learn-lua/">tylerneylon</a>   译文出处：<a href="http://defsniky.com/posts/2014-06-05-learn-lua-in-15-minutes.html">defsniky （@i小雨生）</a></p><p>-- 单行注释<br>–[[<br>    [多行注释]<br>–]]</p><hr><ul><li><ol><li>变量 &amp; 控制流</li></ol></li></ul><hr><p>num = 23 – 数字都是双精度<br>str = ‘aspythonstring’ – 像 Python 一样不可变<br>str = “aspythonuse” – 可以双引号<br>str = [[<br>        像 Python 的多行注释可用于<br>        表示多行字符串一样<br>        方便<br>    ]]</p><p>bol = nil – 未定义；支持垃圾回收</p><span id="more"></span><p>-- 缩进只为易读性，像 Matlab 一样以 end 结尾<br>while num &lt; 50 do<br>    num = num + 1 – 没有 ++ 或 += 自增操作符号<br>end</p><p>– IF 条件开关<br>if num &gt; 40 then<br>    print(‘&gt; 40’)<br>elseif s ~= ‘aspython’ then – ~= 表示 !=<br>    io.write(‘s is not aspython’) – 风骚的标准输出<br>else<br>    thisIsGlobal = 5 – 驼峰式命名<br>    – 显示声明局部变量（像 Javascript 一样）<br>    local line = io.read()</p><pre><code>-- .. 作为字符串连接符print(&#39;凛冬将至&#39; .. line)</code></pre><p>end</p><p>– 引用未定义变量将返回 nil ，这不是错误<br>foo = anUnknownVariable  – 等价于 foo = nil</p><p>aBoolValue = false<br>– 只有 nil 与 false 为逻辑假； 数字 0 与空字串 ‘’ 为真！<br>if not aBoolValue then print(‘false’) end</p><p>– 像 Python 一样运用 ‘or’ 和 ‘and’<br>– 得到 C 语言中 a ? b : c 的效果；需注意 b = false 或 nil 的情况<br>ans = aBoolValue and ‘yes’ or ‘no’</p><p>karlSum = 0<br>for i = 1, 100 do – 像 Matlab 一样的递增语法，包括两端，如同数学中[1, 100]<br>    karlSum = karlSum + i<br>end</p><p>– Step 为 2 递减的方式 ‘100, 1, -2’<br>for j = 100, 1, -2 then print(j) end</p><p>– 综上，范围可表示为 “begin, end [, step]“</p><p>– 另一个循环控制<br>num = 23<br>repeat<br>    print(‘凡人必有一死’)<br>    num = num - 1<br>until num == 0</p><hr><ul><li><ol start="2"><li>函数</li></ol></li></ul><hr><p>function fib(n)<br>    if n &lt; 2 then return 1 end<br>    return fib(n - 2) + fib(n - 1)<br>end</p><p>– Javascript 一样的匿名函数与闭包<br>function adder(x)<br>    – 返回一个函数<br>    – 闭包内封存 x 值<br>    return function (y) return x + y end<br>end<br>a1 = adder(9)<br>a2 = adder(36)<br>print(a1(16))  –&gt; 25<br>print(a2(64))  –&gt; 100</p><p>– 遇到不匹配的列表长度时<br>– 过长的变量将被赋予 nil<br>– 过长的值将被忽略</p><p>x, y, z = 1, 2, 3, 4 – 4 将被忽略<br>function bar(a, b, c)<br>    print(a, b, c)<br>    return 4, 8, 15, 16, 23, 42<br>end<br>x, y = bar(‘zaphod’)  –&gt; “zaphod  nil nil”<br>– x = 4, y = 8, 其余值被忽略</p><p>– 函数与其他类型一样为一等公民<br>– 同样有 local/global 之分<br>– 像 Javascript 一样定义<br>function f(x) return x * x end<br>f = function (x) return x * x end</p><p>print ‘Hello World!’ – 只有一个`字符串`参数时可省略括号</p><hr><ul><li><ol start="3"><li>表(Table) </li></ol></li></ul><hr><p>– 表是 Lua 中唯一的复合类型<br>– 像 PHP 中的数组或 Javascript 中的 Object 一样<br>– 可用作 list/dict/map</p><p>– 默认以字符串作为 key<br>t = {key1 = ‘value1’, key2 = false}<br>– 像 Javascript 一样以 . 取值<br>print(t.key1) –&gt; “value1”<br>t.key3 = {} – 加入新的键值对<br>t.key2 = nil – 销毁一组键值对</p><p>– 理论上任何非 nil 的变量都可以作为 key<br>u = {[‘@!#’] = ‘qbert’, [{}] = 1729, [6.28] = ‘tau’}<br>print(u[6.28])  –&gt; “tau”<br>a = u[‘@!#’] – a = ‘qbert’<br>b = u[{}] – b = nil；像 Javascript 一样 {} 会创建新的对象<br>          – 因此不要用蛋疼的 key 值，老老实实用字串或数字</p><p>– 同字符串一样，只有一个表作为函数的参数时可以省略括号<br>– 为了一个括号增加阅读难度，得不偿失<br>function h(x) print(x.key1) end<br>h{key1 = ‘Sonmi<del>451’}  –&gt; “Sonmi</del>451”</p><p>for key, val in pairs(u) do  – 像 Python  一样的键值迭代<br>    print(key, val)<br>end</p><p>– 像 Javascript 一样的全局作用域 _G<br>print(_G[‘_G’] == _G) –&gt; true</p><p>– 省略 key 之后即可变身为 list<br>– 实际上是以递增自然数为 key<br>v = {‘value1’, ‘value2’, 1.21, ‘gigawatts’}<br>for i = 1, #v do  – 像 Bash 一样，#v 表示列表长度<br>    print(v[i])  – 像 Matlab 一样，列表索引从 1 开始<br>end</p><hr><ul><li>3.1 Metatables &amp; metamethods</li></ul><hr><p>– 元表(metatable)就是表的表，像 Javascript 的原型(prototype)一样<br>– 为表重载一些元方法(metamethods)</p><p>f1 = {a = 1, b = 2}<br>f2 = {a = 2, b = 3}<br>– s = f1 + f2 为错</p><p>mm = {}<br>function mm.__add(x, y)<br>  sum = {}<br>  sum.a = x.a + y.a<br>  sum.b = x.b + y.b<br>  return sum<br>end</p><p>setmetatable(f1, mm)<br>setmetatable(f2, mm)</p><p>– 实际调用 f1 的 metatable 中的 __add(f1, f2)<br>– 只为 f1 设置元表也可以<br>s = f1 + f2 – s = {a = 3, b = 5}</p><p>– s2 = s + s 为错，s 未定义元表</p><p>– __index 元方法重载表中 key 的提取符号 `.`<br>defaultFavs = {animal = ‘gru’, food = ‘donuts’}<br>myFavs = {food = ‘pizza’}<br>setmetatable(myFavs, {__index = defaultFavs})<br>food = myFavs.food</p><p>– Lua 中的值都具有元方法，只有 Table 可以重载<br>– 所有元方法如下</p><p>– __add(a, b)                     for a + b<br>– __sub(a, b)                     for a - b<br>– __mul(a, b)                     for a * b<br>– __div(a, b)                     for a / b<br>– __mod(a, b)                     for a % b<br>– __pow(a, b)                     for a ^ b<br>– __unm(a)                        for -a<br>– __concat(a, b)                  for a .. b<br>– __len(a)                        for #a<br>– __eq(a, b)                      for a == b<br>– __lt(a, b)                      for a &lt; b<br>– __le(a, b)                      for a &lt;= b<br>– __index(a, b)  <fn or a table>  for a.b<br>– __newindex(a, b, c)             for a.b = c<br>– __call(a, …)                  for a(…)</p><hr><ul><li>3.2 类风格的 Table 与继承</li></ul><hr><p>– 像 Javascript 一样并没有内置 Class<br>– 但可以通过 Table `{}` 实现</p><p>Dog = {}                                – 1.<br>function Dog:new()                      – 2.<br>    newObj = {sound = ‘woof’}           – 3.<br>    self.__index = self                 – 4.<br>    return setmetatable(newObj, self)   – 5.<br>end<br>function Dog:makeSound()                – 6.<br>    print(‘I say ‘ .. self.sound)<br>end</p><p>mrDog = Dog:new()                       – 7.<br>mrDog:makeSound() –&gt; “I say woof”</p><p>– 1. Dog 像类但实际是 Table<br>– 2. Dog:new(…) := Dog.new(self, …)<br>– 3. newObj 作 Dog 的实例<br>– 4. self 是 Lua 中默认的参数，在这里 self = Dog<br>–    继承的时候可以改变<br>–    self.__index 与 self 的元方法 __index 不是一回事<br>–    self = {__index = self, metatable = {__index = …}}<br>– 5. setmetatable(newObj, self) 相当于 setmetatable(newObj, {__index = self})<br>–    赋予实例所有类方法<br>– 6. 同 2.<br>– 7. mrDog = Dog.new(Dog)</p><p>– 继承<br>LoudDog = Dog:new()<br>function LoudDog:makeSound()<br>    s = self.sound .. ‘ ‘<br>    print(s .. s .. s)<br>end<br>seymour = LoudDog:new()<br>seymour:makeSound() –&gt; “woof woof woof”</p><hr><ul><li><ol start="4"><li>模块</li></ol></li></ul><hr><p>– 以下来自文件 mod.lua<br>local M = {}</p><p>local function sayMyName()<br>    print(‘Hrunkner’)<br>end</p><p>function M.sayHello()<br>    print(‘Why hello there’)<br>    sayMyName()<br>end<br>return M<br>– 以上<br>– 回到主文件<br>local mod = require(‘mod’) – 运行 mod.lua 中的代码<br>– 操作同下<br>local mod = (function()<br>    – 像 Javascript 一样<br>    –[[<br>        mod.lua 中的代码<br>    ]]–<br>end)()</p><p>mod.sayHello() –&gt; “Why hello there”<br>mod.sayMyName() –&gt; 错！sayMyName() 是 mod.lua 中的局部变量</p><p>– require 返回的值将被缓存<br>– 即使多次调用 require 被调用文件也只运行一次</p><p>– mod2.lua 包含 print(“mod2”)<br>local a = require(“mod2”) –&gt; “mod2”<br>local b = require(“mod2”) – 不输出， 实际为 b = a</p><p>– dofile 是不缓存的版本的 require<br>dofile(“mod2”) –&gt; “mod2”<br>dofile(“mod2”) –&gt; “mod2”</p><p>– loadfile 读取文件但不执行<br>– 勘误：f = loadfile(‘mod2’)，需加后缀名，否则找不到文件<br>f = loadfile(‘mod2.lua’)<br>f() –&gt; “mod2”</p><p>– loadstring 读取代码字符串<br>f = loadstring(“print(‘Lua is cool!’)”)<br>f() –&gt; “Lua is cool!”</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jQuery.cropper中文API详解</title>
    <link href="/2017/10/20/jquery-cropper%E4%B8%AD%E6%96%87api%E8%AF%A6%E8%A7%A3/"/>
    <url>/2017/10/20/jquery-cropper%E4%B8%AD%E6%96%87api%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>jQuery.cropper是一款使用简单且功能强大的图片剪裁jQuery插件。该图片剪裁插件支持图片放大缩小，支持图片旋转，支持触摸屏设备，支持canvas，并且支持跨浏览器使用。 <img src="https://www.zhchi.me/wp-content/uploads/2017/10/cropper-300x169-300x169.png"></p><span id="more"></span><p>cropper提供了大量的参数、方法和事件供图片的剪裁操作。 安装 可以通过Bower或NPM来安装该插件。</p><p>bower install cropper<br>npm install cropper</p><p>使用方法 使用该图片剪裁插件首先要引入必要的js和css文件。</p><script src="/path/to/jquery.js"></script><link  href="/path/to/cropper.css" rel="stylesheet"><script src="/path/to/cropper.js"></script><p>HTML结构 可以将图片或canvas直接包裹到一个块级元素中。</p><!-- Wrap the image or canvas with a block element --><div class="container">    <img src="picture.jpg"></div><p>调用插件 可以使用$.fn.cropper方法来初始化该图片剪裁插件。</p><p>$(‘.container &gt; img’).cropper({<br>    aspectRatio: 16 / 9,<br>    crop: function(data) {<br>        // Output the result data for cropping image.<br>    }<br>});</p><p>注意事项： 注意：剪裁区域的尺寸继承自图片的父容器（包裹容器），所以要确保包裹图片的是一个可见的块级元素。输出的剪裁数据基于原始的图片尺寸，你可以使用这些数据直接剪裁图片。如果你要使用跨源图片来作为剪裁图片，请确保你的浏览器支持HTML5 CORS settings attributes，并且你的图片服务器支持Access-Control-Allow-Origin属性。 配置参数 你可以通过<code>$().cropper(options)</code>方法来设置参数。如果你想改变全局默认参数，可以使用<code>$.fn.cropper.setDefaults(options)</code>方法。 aspectRatio：类型：Number，默认值NaN。设置剪裁容器的比例。 crop：类型：Function，默认值null。当改变剪裁容器或图片时的事件函数。 preview：类型：String(jQuery选择器)，默认值”。添加额外的元素（容器）的预览。 注意： 1.最大宽度是剪裁容器的初始化宽度 最大高度是剪裁容器的初始化高度 如果你设置了aspectRatio参数，确保预览容器具有相同的比例  </p><p>名称</p><p>类型及默认值</p><p>说明</p><p>strict：</p><p>类型：Boolean，默认值true。</p><p>在strict模式中，canvas不能小于容器，剪裁容器不能再canvas之外。</p><p>responsive：</p><p>类型：Boolean，默认值true。</p><p>是否在窗口尺寸改变的时候重置cropper。</p><p>checkImageOrigin：</p><p>类型：Boolean，默认值true。</p><p>默认情况下，插件会检测图片的源，如果是跨域图片，图片元素会被添加crossOrigin class，并会为图片的url添加一个时间戳来使getCroppedCanvas变为可用。添加时间戳会使图片重新加载，以使跨域图片能够使用getCroppedCanvas。在图片上添加crossOrigin class会阻止在图片url上添加时间戳，及图片的重新加载。</p><p>background：</p><p>类型：Boolean，默认值true。</p><p>是否在容器上显示网格背景。</p><p>modal：</p><p>类型：Boolean，默认值true。</p><p>是否在剪裁框上显示黑色的模态窗口。</p><p>guides：</p><p>类型：Boolean，默认值true。</p><p>是否在剪裁框上显示虚线。</p><p>highlight：</p><p>类型：Boolean，默认值true。</p><p>是否在剪裁框上显示白色的模态窗口。</p><p>autoCrop：</p><p>类型：Boolean，默认值true。</p><p>是否在初始化时允许自动剪裁图片。</p><p>autoCropArea：</p><p>类型：Number，默认值0.8（图片的80%）。</p><p>0-1之间的数值，定义自动剪裁区域的大小。</p><p>dragCrop：</p><p>类型：Boolean，默认值true。</p><p>是否允许移除当前的剪裁框，并通过拖动来新建一个剪裁框区域。</p><p>movable：</p><p>类型：Boolean，默认值true。</p><p>是否允许移动剪裁框。</p><p>resizable：</p><p>类型：Boolean，默认值true。</p><p>是否允许改变剪裁框的大小。</p><p>zoomable：</p><p>类型：Boolean，默认值true。</p><p>是否允许放大缩小图片。</p><p>mouseWheelZoom：</p><p>类型：Boolean，默认值true。</p><p>是否允许通过鼠标滚轮来缩放图片。</p><p>touchDragZoom：</p><p>类型：Boolean，默认值true。</p><p>是否允许通过触摸移动来缩放图片。</p><p>rotatable：</p><p>类型：Boolean，默认值true。</p><p>是否允许旋转图片。</p><p>minContainerWidth：</p><p>类型：Number，默认值200。</p><p>容器的最小宽度。</p><p>minContainerHeight：</p><p>类型：Number，默认值100。</p><p>容器的最小高度。</p><p>minCanvasWidth：</p><p>类型：Number，默认值0。</p><p>canvas 的最小宽度（image wrapper）。</p><p>minCanvasHeight：</p><p>类型：Number，默认值0。</p><p>canvas 的最小高度（image wrapper）。</p><p>build：</p><p>类型：Function，默认值null。</p><p>build.cropper事件的简写方式。</p><p>built：</p><p>类型：Function，默认值null。</p><p>built.cropper事件的简写方式。</p><p>dragstart：</p><p>类型：Function，默认值null。</p><p>dragstart.cropper事件的简写方式。</p><p>dragmove：</p><p>类型：Function，默认值null。</p><p>dragmove.cropper事件的简写方式。</p><p>dragend：</p><p>类型：Function，默认值null。</p><p>dragend.cropper事件的简写方式。</p><p>zoomin：</p><p>类型：Function，默认值null。</p><p>zoomin.cropper事件的简写方式。</p><p>zoomout：</p><p>类型：Function，默认值null。</p><p>zoomout.cropper事件的简写方式。</p><p>方法 因为图片是异步加载的，所以你需要在built之后才能调用下面的方法，setAspectRatio、replace和destroy方法例外。</p><p>$().cropper({<br>    built: function () {<br>        $().cropper(‘method’, argument1, , argument2, …, argumentN)<br>    }<br>}</p><p>move(offsetX, offsetY)： 1.offsetX：类型：Number，水平方向上移动的大小，单位像素。 2. offsetY：类型：Number，垂直方向上移动的大小，单位像素。 移动一幅图片：</p><p>$().cropper(‘move’, 1, 0)<br>$().cropper(‘move’, 0, -1)</p><p>zoom(ratio)： ratio： 类型：Number Zoom in：需要一个正数（ratio &gt; 0） Zoom out：需要一个负数（ratio &lt; 0） 缩放一幅图片：</p><p>$().cropper(‘zoom’, 0.1)<br>$().cropper(‘zoom’, -0.1)</p><p>rotate(degree)： ratio： 类型：Number Rotate right：需要一个正数（degree &gt; 0） Rotate left：需要一个负数（degree &lt; 0） 旋转一幅图片，需要CSS3 Transforms3d的支持（IE10+）：</p><p>$().cropper(‘rotate’, 90)<br>$().cropper(‘rotate’, -90)</p><p>enable()：使cropper可用。 disable()：冻结cropper。 reset()：重置剪裁区域的图片到初始状态。 clear()：清空剪裁区域。 replace(url)： url： 类型：String 一个新的图片URL 替换图片的URL重建cropper。 getData()： 返回值： 类型：Object 属性： &lt;1&gt;x：剪裁区域左侧的偏移。 &lt;2&gt;y：剪裁区域距上部的偏移。 &lt;3&gt;width：剪裁区域的宽度。 &lt;4&gt;height：剪裁区域的高度。 &lt;5&gt;rotate：图片的旋转角度。 下图演示从原始图片中返回的剪裁区域数据。   <img src="https://zhchi.me/wp-content/uploads/2017/10/20161009100836523-300x217.png"> getContainerData()： 返回值： 类型：Object 属性： width：容器的当前宽度。 height：容器的当前高度。 输出容器尺寸数据。 getImageData()： 返回值： 类型：Object 属性： left：图片的左侧偏移。 top：图片的上部偏移。 width：图片的宽度。 height：图片的高度。 输出图片的位置和尺寸大小。 getCanvasData()： 返回值： 类型：Object 属性： left：canvas的左侧偏移。 top：canvas的上部偏移。 width：canvas的宽度。 height：canvas的高度。 输出canvas（图片容器）的位置和尺寸大小。 etCanvasData(data)： 返回值： 类型：Object 属性： left：canvas的距离左侧新的偏移。 top：canvas的距离上部新的偏移。 width：canvas新的宽度。 height：canvas新的高度。 改变canvas（图片容器）的位置和尺寸大小。 getCropBoxData()： 返回值： 类型：Object 属性： left：剪裁区域距离左侧的偏移。 top：剪裁区域距离上部的偏移。 width：剪裁区域的宽度。 height：剪裁区域的高度。 输出剪裁区域的位置和尺寸大小。 setCropBoxData(data)： 返回值： 类型：Object 属性： left：剪裁区域距离左侧新的偏移。 top：剪裁区域距离上部新的偏移。 width：剪裁区域新的宽度。 height：剪裁区域新的高度。 改变剪裁区域的位置和尺寸大小。 getCroppedCanvas([options])： 参数（默认值）： 类型：Object 属性： width：输出的canvas目标宽度。 height：输出的canvas目标高度。 fillColor：canvas中填充的颜色。 返回值： 类型：HTMLCanvasElement 一个画有剪裁图片的canvas。 浏览器支持： 基本图像：需要Canvas的支持（IE9+） 旋转图像：需要CSS3 animations Transforms3d的支持（IE10+） 跨域图像：需要HTML5 CORS settings attributes的支持（IE11+） 获取canvas绘制的剪裁图像。 在这之后，你可以直接将canvas作为图片显示，或使用canvas.toDataURL方法获取图像的数据链接，或者使用canvas.toBlob方法获取一个blob，并通过FormData方法将它更新到服务器上（如果浏览器支持这些API）。</p><p>$().cropper(‘getCroppedCanvas’)<br>$().cropper(‘getCroppedCanvas’, {<br>    width: 160,<br>    height: 90<br>});</p><p>setAspectRatio(aspectRatio)： aspectRatio： 类型：Number 需要一个正整数。 改变剪裁区域的比例。 setDragMode([mode])： mode（可选项）： 类型：String 默认值：” 选项：’crop’或’move’ 改变拖拽模式。提示：你可以通过双击来改变”crop” 和 “move”模式。 事件 build.cropper：当cropper对象开始加载图片的时候触发该事件。 built.cropper：当cropper对象构建完成时触发该事件。 dragstart.cropper： event.dragType： “crop”：创建一个新的剪裁区域。 “move”：移动canvas。 “zoom”：通过触摸移动来缩放canvas。 “e”：调整剪裁区域东边的尺寸大小。 “w”：调整剪裁区域西边的尺寸大小。 “s”：调整剪裁区域南边的尺寸大小。 “n”：调整剪裁区域北边的尺寸大小。 “se”：调整剪裁区域东南边的尺寸大小。 “sw”：调整剪裁区域西南边的尺寸大小。 “ne”：调整剪裁区域东北边的尺寸大小。 “nw”：调整剪裁区域西北边的尺寸大小。 “all”：移动剪裁区域。 该事件在剪裁区域发生改变时触发。 相关的原始事件：mousedown、touchstart。</p><p>$(‘img’).on(‘dragstart.cropper’, function (e) {<br>console.log(e.type); // dragstart<br>console.log(e.namespace); // cropper<br>console.log(e.dragType); // …<br>});</p><p>dragmove.cropper： event.dragType：和dragstart.cropper相同。 当剪裁区域发生改变时触发。 相关的原始事件：mousemove、touchmove。 dragend.cropper： event.dragType：和dragstart.cropper相同。 当剪裁区域改变结束时触发。 相关的原始事件：mouseup、mouseleave、touchend、touchleave和touchcancel。 zoomin.cropper：当cropper对象开始放大canvas时触发。 zoomout.cropper：当cropper对象开始缩小canvas时触发。 No conflict：如果你使用了相同名称空间的其它插件，可以通过$.fn.cropper.noConflict方法来修改名称空间。</p><script src="other-plugin.js"></script> <script src="cropper.js"></script> <script> $.fn.cropper.noConflict(); // Code that uses other plugin's "$().cropper" can follow here. </script><p>浏览器兼容 Chrome 38+ Firefox 33+ Internet Explorer 8+ Opera 25+ Safari 5.1+   效果预览：<a href="https://www.zhchi.me/works/cropper/">https://www.zhchi.me/works/cropper/</a></p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CR， LF， CR/LF  回车 换行</title>
    <link href="/2017/10/19/cr%EF%BC%8C-lf%EF%BC%8C-crlf-%E5%9B%9E%E8%BD%A6-%E6%8D%A2%E8%A1%8C/"/>
    <url>/2017/10/19/cr%EF%BC%8C-lf%EF%BC%8C-crlf-%E5%9B%9E%E8%BD%A6-%E6%8D%A2%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>“回车”（Carriage Return）和“换行”（Line Feed）这两个概念的来历和区别。 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33，Linux/Unix下的tty概念也来自于此）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p><span id="more"></span><p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 Unix系统里，每行结尾只有“&lt;换行&gt;”，即”\n”；Windows系统里面，每行结尾是“&lt;换行&gt;&lt;回车 &gt;”，即“\n\r”；Mac系统里，每行结尾是“&lt;回车&gt;”，即”\r”；。一个直接后果是，Unix/Mac系统下的文件在 Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 在文本处理中，CR，LF，CR/LF是不同操作系统上使用的换行符。Dos和windows采用回车+换行CR/LF表示下一行，而UNIX/Linux采用换行符LF表示下一行，苹果机(MAC OS系统)则采用回车符CR表示下一行。 CR用符号’\r’表示，十进制ASCII代码是13，十六进制代码为0x0D；LF使用’\n’符号表示，ASCII代码是10，十六制为0x0A 。 所以Windows平台上换行在文本文件中是使用 0d 0a 两个字节表示，而UNIX和苹果平台上换行则是使用0a或0d一个字节表示。 一般操作系统上的运行库会自动决定文本文件的换行格式，如一个程序在windows上运行就生成CR/LF换行格式的文本文件，而在Linux上运行就生成LF格式换行的文本文件。 在一个平台上使用另一种换行符的文件文件可能会带来意想不到的问题， 特别是在编辑程序代码时，有时候代码在编辑器中显示正常，但在编辑时却会因为换行符问题而出错。很多文本/代码编辑器带有换行符转换功能，使用这个功能可以将文本文件中的换行符在不同格式单互换。 在不同平台间使用FTP软件传送文件时，在ascii文本模式传输模式下，一些FTP客户端程序会自动对换行格式进行转换，经过这种传输的文件字节数可能会发生变化，如果你不想ftp修改原文件，可以使用bin模式(二进制模式)传输文本。</p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>让应用程序支持emoji字符</title>
    <link href="/2017/10/12/%E8%AE%A9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%AF%E6%8C%81emoji%E5%AD%97%E7%AC%A6/"/>
    <url>/2017/10/12/%E8%AE%A9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%AF%E6%8C%81emoji%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>什么是emoji？就是这些表情和符号：😀😄💦😍😂😱😭😴👌 自iPhone从iOS 5在输入法中开始支持emoji以来，这些表情符号迅速风靡世界。但是很多Web网站竟然还不！支！持！！！</p><span id="more"></span><p>那怎么才能支持emoji呢？其实代码一行都不用改，因为emoji符号实际上是文本，并不是图片，它们仅仅显示为图片而已。而且，emoji符号已经被标准化并编码到最新的Unicode标准中了，所以，要支持emoji，只需要底层软件系统支持就可以了。 服务器端要正确存储emoji符号，只需要确保Web程序和底层数据库能支持最新的Unicode标准就可以了。 如果使用MySQL作为数据库，需要升级到5.5.3或更新的版本，然后，把默认编码从原来的utf8改为utf8mb4，在<code>my.cnf</code>或者<code>my.ini</code>配置文件中修改如下：</p><p>[client]<br>default-character-set = utf8mb4</p><p>[mysqld]<br>character-set-server  = utf8mb4<br>collation-server      = utf8mb4_general_ci</p><p>重启MySQL，然后使用以下命令查看编码，应该全部为<code>utf8mb4</code>（character_set_filesystem和character_set_system除外）：</p><p>mysql&gt; show variables like ‘%char%’;<br>+————————–+————————-+<br> Variable_name             Value<br>+————————–+————————-+<br> character_set_client      utf8mb4<br> character_set_connection  utf8mb4<br> character_set_database    utf8mb4<br> character_set_filesystem  binary<br> character_set_results     utf8mb4<br> character_set_server      utf8mb4<br> character_set_system      utf8<br> character_sets_dir        /usr/local/mysql-5.7….<br>+————————–+————————-+<br>8 rows in set (0.00 sec)</p><p>使用命令查看collation设置，应该全部是<code>utf8mb4_general_ci</code>：</p><p>mysql&gt; show variables like ‘%coll%’;<br>+———————-+——————–+<br> Variable_name         Value<br>+———————-+——————–+<br> collation_connection  utf8mb4_general_ci<br> collation_database    utf8mb4_general_ci<br> collation_server      utf8mb4_general_ci<br>+———————-+——————–+<br>3 rows in set (0.01 sec)</p><p>如果<code>character_set_database</code>还是为<code>utf8</code>，需要重启服务器。 现在，MySQL就可以正确存储emoji字符了。 Web软件 要支持emoji，需要Web软件也支持。目前，已知支持emoji的包括：</p><ul><li>  Java 8</li><li>  Node</li></ul><p>最后，如果你的Web应用程序没有使用标准的UTF-8编码，而是使用了GBK等编码，想要支持emoji就只能呵呵了       转自<a href="https://www.liaoxuefeng.com/article/00145803336427519ae82a6c5b5474682c0c4ba5b47fb33000">廖雪峰的官方网站</a></p>]]></content>
    
    
    <categories>
      
      <category>我的博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>emoji</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
